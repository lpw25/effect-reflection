\documentclass[acmsmall, screen, nonacm]{acmart}

\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{fontawesome5}
\usepackage{mathpartir}
\usepackage{sourcecodepro}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\lstset{
  basicstyle=\ttfamily\small,
  columns=fullflexible,
  keepspaces=true
}

\lstdefinestyle{oxcaml}{
  keywordstyle=\color{blue},
  emphstyle=\color{violet},
  language=[Objective]Caml,
  morekeywords={effect, exclave},
  escapeinside={(*@}{@*)},
  literate=
    {[]}{$\glob$}{1}
}

\lstdefinestyle{haskell}{
  keywordstyle=\color{blue},
  emphstyle=\color{violet},
  language=Haskell
}

\newcommand{\nat}{\mathbb{N}}
\newcommand{\glob}{\mathop{\Box}}
\newcommand{\cat}{\mathbb{C}}
\newcommand{\catobj}{C}
\newcommand{\op}{\mathtt{op}}
\newcommand{\catop}{\cat^{\op}}
\newcommand{\id}[1]{\mathrm{id}_{#1}}
\newcommand{\setc}{\mathrm{Set}}
\newcommand{\psh}{\widehat{\cat}}
\newcommand{\terminal}{\top}
\newcommand{\initial}{\bot}
\newcommand{\lawc}{\mathrm{Law}}
\newcommand{\lawcop}{\lawc^{\mathtt{op}}}
\newcommand{\pshlawcop}{\widehat{\lawcop}}
\newcommand{\freef}{Free}
\newcommand{\constfname}{\Omega}
\newcommand{\constf}[1]{\constfname #1}
\newcommand{\yonedaname}{y}
\newcommand{\yoneda}[1]{y(#1)}
\newcommand{\homset}[3]{\mathrm{Hom}_{#1}(#2, #3)}
\newcommand{\arrow}[2]{{#2}^{#1}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\reflectname}{\Uparrow}
\newcommand{\reflectraw}[1]{\mathop{\reflectname_{#1}}}
\newcommand{\reflect}[3]{\reflectraw{#1}(#2, #3)}
\newcommand{\reflectc}[2]{\mathop{\reflectname_{#1 #2}}}
\newcommand{\performraw}[2]{\mathop{\reflectname(#1(#2))}}
\newcommand{\perform}[5]{\performraw{#1}{#2}(#3, #4. #5)}
\newcommand{\reifyname}{\Downarrow}
\newcommand{\reifyraw}[1]{\mathop{\reifyname_{#1}}}
\newcommand{\reify}[3]{\reifyraw{#1}(#2.\,#3)}
\newcommand{\reifyc}[2]{\mathop{\reifyname_{#1 #2}}}
\newcommand{\outlname}{\mathrm{out}_L}
\newcommand{\outl}[1]{\mathop{\outlname} #1}
\newcommand{\outrname}{\mathrm{out}_R}
\newcommand{\outr}[1]{\mathop{\outrname} #1}
\newcommand{\mon}{\mathcal{T}}
\newcommand{\ind}[1]{W_{#1}}
\newcommand{\indintro}[4]{#2_{#1}(#3,\, #4)}
\newcommand{\retname}{\mathrm{ret}}
\newcommand{\ret}[2]{\mathop{\retname_{#1}}(#2)}
\newcommand{\indelim}[3]{\mathop{\mathrm{rec}_{#1}} #2 \,\{#3\}}
\newcommand{\indretcase}[2]{\retname(#1) \Rightarrow #2}
\newcommand{\indcase}[4]{#1(#2, #3) \Rightarrow #4}
\newcommand{\seq}{\,;\,}
\newcommand{\fst}{\mathop{\pi_1}}
\newcommand{\snd}{\mathop{\pi_2}}
\newcommand{\inl}[1]{\mathop{\mathrm{in}_L} #1}
\newcommand{\inr}[1]{\mathop{\mathrm{in}_R} #1}
\newcommand{\case}[5]{\mathop{\mathrm{case}} #1 \,\{\,\inl{#2} \Rightarrow #3 \seq \inr{#4} \Rightarrow #5 \,\}}
\newcommand{\abs}[3]{\mathop{\lambda}(#1 \types #2).\,#3}
\newcommand{\app}[2]{#1\,#2}
\newcommand{\types}{\mathrel{:}}
\newcommand{\gtypes}{\mathrel{:_{\Box}}}
\newcommand{\cempty}{\varepsilon}
\newcommand{\ccons}[2]{#1;\,#2}
\newcommand{\lbind}[3]{\ccons{#1}{#2\types#3}}
\newcommand{\gbind}[3]{\ccons{#1}{#2\gtypes#3}}
\newcommand{\cdiv}[1]{#1/\Box}
\newcommand{\return}[1]{\mathop{\mathrm{return}} #1}
\newcommand{\letv}[3]{\mathop{\mathrm{let}} #1 = #2 \mathop{\mathrm{in}} #3}
\newcommand{\gbox}[1]{\mathop{\mathrm{box}} #1}
\newcommand{\gunbox}[3]{\mathop{\mathrm{let}} (\gbox #1) = #2 \mathop{\mathrm{in}} #3}
\newcommand{\grun}[1]{\mathop{\mathrm{run}}(#1)}
\newcommand{\sbst}[3]{#1[#2\backslash#3]}
\newcommand{\turnv}{\mathrel{\vdash_V}}
\newcommand{\turnc}{\mathrel{\vdash_C}}
\newcommand{\evmap}{\mathop{ev}}
\newcommand{\currymap}{\mathop{\lambda}}
\newcommand{\reducestov}{\rightsquigarrow_V}
\newcommand{\reducestoc}{\rightsquigarrow_C}
\newcommand{\mif}{\mathop{\mathrm{if}}}
\newcommand{\mthen}{\mathop{\mathrm{then}}}
\newcommand{\melse}{\mathop{\mathrm{else}}}
\newcommand{\embed}[1]{\mathopen{\lbag}#1\mathclose{\rbag}}

\newcommand{\todo}[1]{{\color{red}TODO: #1}}

\title{Locality and Effect Reflection}
\author{Leo White}
\affiliation{\institution{Jane Street}\country{UK}}
\date{}
\setcopyright{none}

\begin{document}

\begin{abstract}
  Algebraic effects and handlers allow the programmer to extend their
  language's \emph{ambient monad} \textbf{--} the monad describing which
  effects ordinary functions can perform \textbf{--} with additional
  effectful operations.

  Locality captures the general idea of a value depending on some notion
  of ``location''. We can represent it in a type system using a
  comonadic \emph{global modality} $\glob$ that tracks which values do
  not depend on their location. A particularly useful notion of
  ``location'' is the ambient monad.

  We introduce an alternative presentation of algebraic effects and
  handlers, \emph{effect reflection}, that provides, for any algebraic
  signature $\Sigma$, an isomorphism:
  \begin{equation*}
    \ind{\Sigma}(\glob \tau) \qquad \cong \qquad \yoneda{\Sigma} \rightarrow \glob \tau
  \end{equation*}
  where $\ind{\Sigma}$ is an inductive type representing the free
  algebra of $\Sigma$, and $\yoneda{\Sigma}$ is a type representing how
  to inject terms of $\Sigma$ into the current ambient
  monad. $\ind{\Sigma}$ is sometimes called the \emph{freer monad} of
  $\Sigma$. This presentation falls out naturally from a simple
  denotational semantics for algebraic effects in terms of presheaves
  over bounded Lawvere theories.

  Effect reflection lets you work with any algebraic monad using an
  ordinary function type, allowing effectful code to be written in
  direct style. This provides all the benefits of typed algebraic
  effects and handlers without requiring an effect system or other
  specific additions to the type system. We demonstrate effect
  reflection by implementing it as a library in
  OxCaml\cite{lorenzen2024oxidizing} and working through some classic
  examples of programming with effects.
\end{abstract}

\maketitle

\section{Reflection for algebraic effects}

\subsection{Algebraic effects}
Algebraic effects and handlers are an increasingly popular approach to
programming with effects. Handlers allow the programmer to add
additional effects to the \emph{ambient monad} of their language -- the
monad describing which effects an ordinary function can perform -- for
some region of their program.

For example, in OCaml, one can write:
\begin{lstlisting}[style=oxcaml]
  type 'a Effect.t +=
    | Get : int Effect.t
    | Set : int -> unit Effect.t

  let handle_state (f : unit -> 'a) : 'a =
    match f () with
    | x -> fun _ -> x
    | effect Get, k -> fun s -> continue k s s
    | effect Set s', k -> fun _ -> continue k () s'
\end{lstlisting}
and for the duration of the \lstinline[style=oxcaml]{f ()} function call
the ambient monad is extended with two additional effectful operations:
\begin{lstlisting}[style=oxcaml]
  let get () : int = perform Get
  let set (i : int) : unit = perform (Set i)
\end{lstlisting}

Note that, in OCaml, the effects are \emph{untracked}: nothing prevents
attempting to perform an algebraic effect operation that is not
supported by the current ambient monad, resulting in an
\lstinline[style=oxcaml]{Unhandled} exception being raised.

Other languages track effects to ensure that operations are only
performed when they are supported. However, these require extending the
type system with explicit mechanisms for tracking effects, as in
Koka\cite{leijen2017type}, or for tracking a general notion of
capability, as in Effekt\cite{brachthauser2022effects}.

The ``Lightweight effect polymorphism'' approach of Brachthauser et
al. elegantly manages to track effects without requiring explicit
effect-tracking machinery in the type system. However, it is restricted
to second-class functions. We would like to extend this approach to
first-class functions without having to fall back to explicit
effect-tracking machinery.

\subsection{Locality and effect reflection}
Locality captures the general idea of a value depending on some notion
of ``location''. We can represent it in a type system using a comonadic
\emph{global modality} $\glob$ that tracks which values do not depend on
their location. A particularly useful notion of ``location'' is the
ambient monad.

Treating the ambient monad as a notion of location allows a language to
provide, for any algebraic signature $\Sigma$, an isomorphism:
\begin{equation*}
  \ind{\Sigma}(\glob \tau) \qquad \cong \qquad \yoneda{\Sigma} \rightarrow \glob \tau
\end{equation*}
where $\ind{\Sigma}$ is an inductive type representing the free
algebra of $\Sigma$, and $\yoneda{\Sigma}$ is a type representing how
to inject terms of $\Sigma$ into the current ambient
monad. $\ind{\Sigma}$ is sometimes called the \emph{freer monad} of
$\Sigma$. We call this isomorphism \emph{effect reflection}.

The ability to use the ordinary arrow type
$\yoneda{\Sigma} \mathbin{\rightarrow} \glob X$ in place of the monad
$\ind{\Sigma}(\glob X)$ allows us to conveniently write effectful code,
using multiple effects, in direct style, just as algebraic effects do.

\subsection{Effect reflection in OxCaml}
OxCaml\cite{lorenzen2024oxidizing} provides type system support for
tracking locality and runtime support for algebraic effects. For
backwards compatibility with OCaml, an unadorned arrow type
\lstinline[style=oxcaml]{t -> s} is treated as if the parameter and
return types were actually \lstinline[style=oxcaml]{[]t} and
\lstinline[style=oxcaml]{[]s}. To get parameters or results that are not
implicitly global, we write
e.g. \lstinline[style=oxcaml]{t @ local -> s @ local}.

Using this support, with can provide effect reflection as a simple API
that we can use for programming with effects.  For example, we can use
it to write an effect handler equivalent to the OCaml one above:
\begin{lstlisting}[style=oxcaml]
  module State = struct
    type 'a t =
      | Get : int t
      | Set : int -> unit t
  end

  module State_eff = Reflection(State)

  let handle_state (f : Handler(State).t @ local -> 'a) (i : int) : 'a =
    let rec loop s : 'a Term(State).t @ local -> 'a  = function
      | Return x -> x
      | Op(Get, k) -> loop s (k s)
      | Op(Set s', k) -> loop s' (k ())
    in
    loop i (State_eff.reify_local f)
\end{lstlisting}
which calls \lstinline[style=oxcaml]{f} and passes it a local value of
type \lstinline[style=oxcaml]{Handler(State).t}. For the duration of the
call to \lstinline[style=oxcaml]{f} the ambient monad is extended with
two additional effectful operations, which can be used via reflection:
\begin{lstlisting}[style=oxcaml]
  let get (h : Handler(State).t @ local) : int =
    State_eff.perform Get h

  let set (h : Handler(State).t @ local) (i : int) : unit =
    State_eff.perform (Set i) h
\end{lstlisting}

Note that the locality of the handler value ensures that these
operations can only be performed when they are available in the ambient
monad. This provides the same guarantees as using an effect system.

\subsection{Denotational semantics} The design of effect reflection falls
out naturally from a simple denotational semantics of algebraic
effects. The underlying idea is to index the semantics by the ambient
monad. Rather than the semantics of a type being a set it is instead a
function from ambient monads to set: if you tell it what the ambient
monad is it can tell you what its set of values is.

The semantics is defined in terms of presheaves of the opposite of the
category of \emph{bounded Lawvere theories}. Bounded Lawvere theories
are a categorical representation of algebraic theories: we represent the
ambient algebraic monad by the corresponding algebraic theory. The key
constructs of effect reflection are then defined as follows:

\begin{itemize}
\item The ambient monad can be defined as a monad $\mon$ on such
  presheaves, which maps each algebraic theory to its free algebras. We use
  $\mon$ to define the semantics of computations.

\item The global modality $\glob$ on such presheaves is defined such
  that $\glob(P)(L) = P(\initial)$. In other words, for a given presheaf
  $P$ it gives the constant presheaf that always ignores the ambient
  monad and instead returns $P$ at $\initial$, where $\initial$ is the
  algebraic theory with no operations or equations. This allows us to
  restrict a type to its terms that do not depend on the ambient monad.

\item The semantics of our handler types $\yoneda{\Sigma}$ are given by
  the Yoneda embedding, and our effect reflection isomorphism becomes a
  simple consequence of the Yoneda lemma and some properties of the sums
  of algebraic theories.
\end{itemize}

\subsection{Structure of the paper} We proceed as follows:
\begin{itemize}
\item In Section \ref{sec:practice}, we give an overview of effect reflection in
  practice in OxCaml.
\item In Section \ref{sec:language}, we define a simply typed calculus featuring
  effect reflection.
\item In Section \ref{sec:semantics}, we describe our denotational
  semantics of effect reflection.
\item In Section \ref{sec:implementation}, we give an implementation of effect
  reflection in OxCaml in terms of the untracked algebraic effects it
  inherits from OCaml.
\item In Section \ref{sec:related-work}, we discuss related work.
\end{itemize}

\section{Effect reflection in practice}
\label{sec:practice}

We can provide effect reflection as a simple library API in OxCaml. In
this section we describe this API and show how to use it to write a
number of typical examples of algebraic effects.

\subsection{Locality in OxCaml}

The effect reflection API relies on OxCaml's support for tracking
locality in types, so let's start with an overview of that support.

Values in OxCaml are associated with both a type -- which describe how
values can be introduced and eliminated -- and a \emph{mode} -- which
track properties related to operations other than introduction and
elimination. Modes are a product of a number of different axes, tracking
a variety of different properties, but here we are only interested in
one of them: \emph{locality}. Ignoring the other axes, a mode is either
\lstinline[style=oxcaml]{local} or \lstinline[style=oxcaml]{global}.

Locality tracks the ability of a value to leave \emph{regions}.  Regions
describe some period of time during a program's execution. Every
function call defines a corresponding region that, by default, lasts for
the entire extent of the call. This means that, by default,
\lstinline[style=oxcaml]{local} values cannot be returned from a
function.
\begin{lstlisting}[style=oxcaml]
let leak_local x =
  let (o @ local) = Some x in
  o
(*@ \textcolor{red}{Error: o} @*)
       (*@ \textcolor{red}{\textasciicircum} @*)
(*@ \textcolor{red}{This value is local and would escape its region.} @*)
\end{lstlisting}

To support functions that return local values, the region of a function
can be ended early using the \lstinline[style=oxcaml]{exclave} construct.
\begin{lstlisting}[style=oxcaml]
let return_local x =
  exclave
    (let (o @ local) = Some x in
     o)
\end{lstlisting}
\lstinline[style=oxcaml]{exclave e} can only appear in tail position
within a function.  It ends the function's region early and then
executes the expression
\lstinline[style=oxcaml]{e}. \lstinline[style=oxcaml]{e} is essentially
executed within the region of the caller of the function and any local
values created within it can be safely returned to that caller.

The place where modes appear within the type algebra is on arrow
types. A function being \lstinline[style=oxcaml]{global} doesn't tell you
that the values it accepts or returns should be
\lstinline[style=oxcaml]{global} too, so instead the arrow type is
labelled with two modes: one for the argument and one for the return
value.
\begin{lstlisting}[style=oxcaml]
val return_local : 'a @ local -> 'a option @ local
\end{lstlisting}
For convenience, and backwards compatibility with OCaml, either mode can
be omitted, in which case it defaults to
\lstinline[style=oxcaml]{global}.

By default, modes are deep: a local \lstinline[style=oxcaml]{string list}
is a local list of local strings. However, the depth that a mode applies
can be controlled via \emph{modalities}. Record fields can be annotated
with \lstinline[style=oxcaml]{global} modality to indicate that the
contents of the field are global even when the surrounding record is
local. For example:
\begin{lstlisting}[style=oxcaml]
type 'a gbl = { g : 'a @@ global }
\end{lstlisting}
gives a record whose only field has the \lstinline[style=oxcaml]{global}
modality. The contents of the \lstinline[style=oxcaml]{g} field is always
global, for example:
\begin{lstlisting}[style=oxcaml]
let project_global (r @ local) =
  r.g
\end{lstlisting}
gives a function of type:
\begin{lstlisting}[style=oxcaml]
val project_global : 'a gbl @ local -> 'a @ global
\end{lstlisting}
Variant constructor arguments can also be annotated with modalities.

Note that, whilst there is a \lstinline[style=oxcaml]{global} modality,
there is no \lstinline[style=oxcaml]{local} modality. It does not make
sense for a value which has the ability to leave a region to contain a
value which doesn't, as when the first value leaves a region it will
implicitly cause the second one to leave that region as well. This means
the \lstinline[style=oxcaml]{global} mode is always deep.

\subsection{Effect reflection interface}
\label{sec:interface}

The types and operations of our effect reflection API are parameterized
by type constructors representing the operations of an algebraic
effect. In OxCaml, such higher-kinded interfaces must be built using
functors, so we start with a simple module type
\lstinline[style=oxcaml]{Op} to act as the parameter type for these
functors:
\begin{lstlisting}[style=oxcaml]
module type Op = sig type 'a t end
\end{lstlisting}
The fundamental types of the API are the \lstinline[style=oxcaml]{Term}
and \lstinline[style=oxcaml]{Handler} types.
\begin{lstlisting}[style=oxcaml]
module Term (O : Op) : sig
  type 'a t =
    | Return : 'a @@ global -> 'a t
    | Op : 'r O.t @@ global * ('r -> 'a t) -> 'a t
end

module Handler(O : Op) : sig
  type t
end
\end{lstlisting}
For an effect signature \lstinline[style=oxcaml]{O},
\lstinline[style=oxcaml]{'a Term(O).t} is the type of terms in the free
algebra of the corresponding effect -- otherwise known as the freer
monad\cite{kiselyov2015freer}. \lstinline[style=oxcaml]{Handler(O).t} is
the type of mappings from the operations of \lstinline[style=oxcaml]{O}
into the operations of the current ambient monad. Alternatively,
\lstinline[style=oxcaml]{Handler(O).t} can be described as representing
algebraic effect handlers that are handling the current computation --
hence the name.

The main piece of the API is a family of isomorphisms:
\begin{equation*}
  \text{\lstinline[style=oxcaml]{'a Term(O).t}} \qquad
  \cong \qquad \text{\lstinline[style=oxcaml]{Handler(O).t @ local -> 'a}}
\end{equation*}
Due to the absence of mode polymorphism in OxCaml, we expose this
isomorphism as three functions: \lstinline[style=oxcaml]{reify} and
\lstinline[style=oxcaml]{reify_local} which implement the left-to-right
direction at the \lstinline[style=oxcaml]{global} and
\lstinline[style=oxcaml]{local} modes respectively; and
\lstinline[style=oxcaml]{perform}, which is equivalent to the
right-to-left direction but makes for a more convenient primitive in
practice. \lstinline[style=oxcaml]{perform} amounts to reflection of
individual operations as opposed to full terms.
\begin{lstlisting}[style=oxcaml]
module Reflection (O : Op) : sig
  val reify : (Handler(O).t @ local -> 'a) -> 'a Term(O).t

  val reify_local :
    (Handler(O).t @ local -> 'a) @ local -> 'a Term(O).t @ local

  val perform : 'a O.t -> (Handler(O).t @ local -> 'a)
end
\end{lstlisting}
Using \lstinline[style=oxcaml]{perform} we can implement reflection of
global terms as:
\begin{lstlisting}[style=oxcaml]
let rec reflect t h =
  match t with
  | Return x -> x
  | Op(op, k) -> reflect (k (perform op h)) h
\end{lstlisting}
with type:
\begin{lstlisting}[style=oxcaml]
val reflect : 'a Term(O).t -> (Handler(O).t @ local -> 'a)
\end{lstlisting}
Reflection of local terms can be defined similarly.

\subsection{Example: State}

As shown in the introduction we can implement an effect handler for
state using this API. We start by defining the operations of the effect:
\begin{lstlisting}[style=oxcaml]
module State = struct
  type 'a t =
    | Get : int t
    | Set : int -> unit t
end
\end{lstlisting}
Then we instantiate the reflection isomorphism for that effect and use
it to write a handler:
\begin{lstlisting}[style=oxcaml]
module State_eff = Reflection(State)

let handle_state f i =
  let rec loop s = function
    | Term(State).Return x -> x
    | Term(State).Op(Get, k) -> loop s (k s)
    | Term(State).Op(Set s', k) -> loop s' (k ())
  in
  loop i (State_eff.reify_local f)
\end{lstlisting}
Finally we add an alias for the handler type and some convenient
wrappers for the generic effects:
\begin{lstlisting}[style=oxcaml]
type handler = Handler(State).t

let get h =
  State_eff.perform Get h

let set h i =
  State_eff.perform (Set i) h
\end{lstlisting}
Giving us the following interface:
\begin{lstlisting}[style=oxcaml]
type handler

val handle_state : (handler @ local -> 'a) @ local -> int -> 'a
val get : handler @ local -> int
val set : handler @ local -> int -> unit
\end{lstlisting}
Note that we are able to use \lstinline[style=oxcaml]{reify_local} to allow
the function passed to \lstinline[style=oxcaml]{handle_state} to be local.

This shows how to implement state using effect reflection, but note that
the same interface can also be implemented directly using mutable state
and locality:
\begin{lstlisting}[style=oxcaml]
type handler = int ref

let handle_state f i = f (ref i)
let get r = !r
let set r i = r := i
\end{lstlisting}
This implementation gives the same behaviour as the one built using
effect reflection. Crucially it is just as easy to reason about, which
in turn means it is just as easy to reason about as the state monad. In
some sense, the improved reasoning ability of the state monad over
ordinary mutable state is precisely captured by the notion of locality.

This transformation from effect reflection to local mutable state works
for any \emph{tail-resumptive} effect handler.

\subsection{Lightweight effect polymorphism}

The following function uses state to calculate the total of a list of
integers:
\begin{lstlisting}[style=oxcaml]
let total l =
  handle_state (fun h ->
    List.iter (fun x -> set h (get h + x)) l;
    get h)
\end{lstlisting}
This relies on the locality of the function parameter of
\lstinline[style=oxcaml]{List.iter}:
\begin{lstlisting}[style=oxcaml]
val iter : ('a -> unit) @ local -> 'a list -> unit
\end{lstlisting}
The \lstinline[style=oxcaml]{local} annotation on the parameter ensures
that any function passed will not escape the current region. This allows
us to pass in a closure that closes over the
\lstinline[style=oxcaml]{local} handler \lstinline[style=oxcaml]{h} and
use it to perform some effects.

This ability for higher-order functions like
\lstinline[style=oxcaml]{List.iter} to be reused with different ambient
monads achieves the ``lightweight effect polymorphism'' described by
Brachth{\"a}user et al.\cite{brachthauser2020effects} without requiring
a separate notion of second-class function.

\subsection{Example: Generators}

A more realistic use of effect reflection is a \emph{generator}
effect. This effect has a single operation:
\begin{lstlisting}[style=oxcaml]
module Gen = struct
  type 'a t =
    | Gen : int -> unit t
end
\end{lstlisting}
Along with a handler that turns computations using
\lstinline[style=oxcaml]{Gen} into streams of integers.
\begin{lstlisting}[style=oxcaml]
module Gen_eff = Reflection(Gen)

type ints =
  | Finished
  | More of int * (unit -> ints)

let handle_gen f =
  let rec loop = function
    | Term(Gen).Return () -> Finished
    | Term(Gen).Op(Gen i, k) -> More(i, k)
  in
  loop (Gen_eff.reify f)
\end{lstlisting}

Unlike the state handler, here we must use
\lstinline[style=oxcaml]{reify} rather than
\lstinline[style=oxcaml]{reify_local} because our intention is that the
resulting stream of integers be a global value that can escape the
current region. Since it closes over the continuation
\lstinline[style=oxcaml]{k}, we must use \lstinline[style=oxcaml]{reify}
and require that \lstinline[style=oxcaml]{f} be global:
\begin{lstlisting}[style=oxcaml]
val handle_gen : (Handler(Gen).t @ local -> unit) -> ints
\end{lstlisting}

\subsection{Example: Asynchronous I/O}

Perhaps the most common use case for algebraic effects is for
concurrency and asynchronous I/O. Implementing asynchronous I/O from
scratch is beyond the scope of this paper, but we can build a simple
version on top of an existing monadic concurrency library. Assuming we
have a monadic future type \lstinline[style=oxcaml]{'a Deferred.t} we can
write concurrent code in direct style by using an effect with a single
\lstinline[style=oxcaml]{Await} operation that waits for a future to be
completed:
\begin{lstlisting}[style=oxcaml]
module Await : sig
  type 'a t =
    | Await : 'a Deferred.t -> 'a t
end
\end{lstlisting}

\begin{lstlisting}[style=oxcaml]
module Await_eff = Reflection(Await)

let handle_await f =
  let rec loop = function
    | Term(Await).Return x -> Deferred.return x
    | Term(Await).Op(Await d, k) ->
        Deferred.bind d (fun x -> loop (k x))
  in
  loop (Await_eff.reify f)

let await h d =
  Await_eff.perform (Await d) h
\end{lstlisting}

Using this we can write direct-style code using asynchronous I/O:
\begin{lstlisting}[style=oxcaml]
let copy_file h src dst =
  let s = await h (File.read src) in
  await h (File.write dst s)
\end{lstlisting}

\subsection{One-shot continuations}

For various practical reasons, OCaml's algebraic effects are restricted
to only allow continuations to be resumed a single time. This rules out
interesting effects like backtracking search, but improves the ability
to reason about the interaction of effects and resources.

There is no fundamental reason that effect reflection should be
restricted to only one-shot continuations, so for the purposes of this
paper we shall ignore the restriction. However, for the same reasons as
OCaml, our actual implementation is restricted one-shot
continuations. Note that OxCaml's \lstinline[style=oxcaml]{once}
mode\cite{lorenzen2024oxidizing} allows us to enforce this restriction
statically.

\subsection{Nested effect handlers}

A key feature of algebraic effects is how easy they are to compose. We
can use state whilst using asynchronous I/O by simply nesting their
handlers:
\begin{lstlisting}[style=oxcaml]
handle_await (fun ch ->
  handle_state i (fun sh ->
    List.iter files (fun fl ->
      let s = await ch (File.read fl) in
      let i = int_of_string s in
      set sh (i + get sh));
    get sh))
\end{lstlisting}

This relies on the fact that the \lstinline[style=oxcaml]{handle_state}
uses \lstinline[style=oxcaml]{reify_local} and so is able to operate on a
local computation that closes over the local handler value
\lstinline[style=oxcaml]{ch}.

If we tried to do something similar using our
\lstinline[style=oxcaml]{handle_gen} handler, then we get and error:
\begin{lstlisting}[style=oxcaml]
handle_await (fun ch ->
  handle_gen i (fun gh ->
    List.iter files (fun fl ->
      let s = await ch (File.read fl) in
      let i = int_of_string s in
      gen gh i)))
(*@ \textcolor{red}{Error: let s = await ch (File.read fl) in} @*)
                     (*@ \textcolor{red}{\textasciicircum\textasciicircum} @*)
(*@ \textcolor{red}{ This value is local and would escape its region.} @*)
\end{lstlisting}

We could change the definition of \lstinline[style=oxcaml]{handle_gen} to
use \lstinline[style=oxcaml]{reify_local} instead of
\lstinline[style=oxcaml]{reify}, but then we would lose the property that
the generator we produce can be passed around freely. Instead we need to
build a handler that can forward the \lstinline[style=oxcaml]{Await}
operation to different effect handlers at different points in the
program's execution.

\subsection{Effect sums and effect forwarding}

Composing handlers, like \lstinline[style=oxcaml]{handle_gen}, that use
\lstinline[style=oxcaml]{reify} rather than
\lstinline[style=oxcaml]{reify_local} is a fundamentally more involved
operation. Consider the case of generators that are able to use
asynchronous I/O. We are given a computation that performs both
\lstinline[style=oxcaml]{Await} and \lstinline[style=oxcaml]{Gen}
operations and we'd like to turn it into a stream of integers.  We would
like to be able to freely pass this stream around. In particular, we do
not wish the stream to be prevented from escaping the scope of the
current \lstinline[style=oxcaml]{Await} handler.  However forcing parts
of the stream requires performing additional
\lstinline[style=oxcaml]{Await} operations. Whenever we force part of the
stream we'll need to provide a handler for those
\lstinline[style=oxcaml]{Await} operations.

To achieve this more general form of composition, we require an
additional capability in our effect reflection API. We need to be able
to manipulate \lstinline[style=oxcaml]{Handler} types for sums of
effects.
\begin{lstlisting}[style=oxcaml]
module Sum (L : Op) (R : Op) : sig
  type 'a t =
    | Left : 'a L.t -> 'a t
    | Right : 'a R.t -> 'a t
end

module Project(L : Op) (R : Op) : sig
  val outl : Handler(Sum(L)(R)).t -> Handler(L).t

  val outr : Handler(Sum(L)(R)).t -> Handler(R).t
end
\end{lstlisting}

\lstinline[style=oxcaml]{Sum(L)(R)} is the coproduct of the effects
\lstinline[style=oxcaml]{L} and \lstinline[style=oxcaml]{R}. Terms in
the free algebras of the sum of two effects
(i.e. \lstinline[style=oxcaml]{Term(Sum(L)(R)).t}) are isomorphic to a
recursive datatype that is built from the terms of one of the effects
and the operations of the other\cite{hyland2006combining}. We can define
this type and associated isomorphism as:
\begin{lstlisting}[style=oxcaml]
module Half_term (L : Op) (R : Op) : sig
  type 'a t =
    | Return : 'a @@ global -> 'a t
    | Op : 'r R.t @@ global * ('r -> Handler(L).t @ local -> 'a t) -> 'a t
end

module Half_reflection (L : Op) (R : Op) : sig
  val reify :
    (Handler(L).t @ local -> Handler(R).t @ local -> 'a)
    -> Handler(L).t @ local -> 'a Half_term(L)(R).t

  val reflect :
    (Handler(L).t @ local -> 'a Half_term(L)(R).t)
    -> Handler(L).t @ local -> Handler(R).t @ local -> 'a
end
\end{lstlisting}

Note that the key difference between
\lstinline[style=oxcaml]{Half_term(L)(R).t} and
\lstinline[style=oxcaml]{Term(R).t} is that continuing the computation
after an operation requires passing in a local
\lstinline[style=oxcaml]{Handler(L).t} again.

%\begin{lstlisting}[style=oxcaml]
%module Half_reflection (L : Op) (R : Op) : sig
%  module L_eff = Reflection(L)
%  module R_eff = Reflection(R)
%  module Sum_eff = Reflection(Sum(L)(R))
%  module Proj = Project(L)(R)
%
%  let reify (f : Handler(L).t @ local -> Handler(R).t @ local -> 'a) lh =
%    let rec loop lh = function
%      | Term(Sum(L)(R)).Return ->
%          Half_term(L)(R).Return v
%      | Term(Sum(L)(R)).Op(Left op, k) ->
%          loop lh (k (L_eff.perform op lh))
%      | Term(Sum(L)(R)).Op(Right op, k) ->
%          Half_term(L)(R).Op(op, (fun res lh -> loop lh (k res)))
%    in
%    loop (Sum_eff.reify (fun h -> f (Proj.outl h) (Proj.outr h))) lh
%
%  let rec reflect (f : Handler(L).t @ local -> 'a Half_term(L)(R).t) lh rh =
%    match f lh with
%    | Return x -> x
%    | Op(op, k) -> reflect (k (R_eff.perform op rh)) lh rh
%end
%\end{lstlisting}

Now we can use this machinery to conveniently build a handler of
\lstinline[style=oxcaml]{Gen} that also forwards operations from
\lstinline[style=oxcaml]{Await}:
\begin{lstlisting}[style=oxcaml]
module Await_gen_eff = Half_reflection(Await)(Gen)

type aints =
  | Finished
  | More of int * (Handler(Await).t @ local -> aints)

let handle_gen_in_await f ah =
    let rec loop = function
    | Half_term(Await)(Gen).Return () -> Finished
    | Half_term(Await)(Gen).Op(Gen i, k) -> More(i, fun ah -> loop (k () ah))
  in
  loop (Await_gen_eff.reify f ah)
\end{lstlisting}
where \lstinline[style=oxcaml]{handle_gen_in_await} has the type:
\begin{lstlisting}[style=oxcaml]
val handle_gen_in_await :
  (Handler(Await).t @ local -> Handler(Gen).t @ local -> 'a)
  -> Handler(Await).t @ local
  -> aints
\end{lstlisting}

The literature on lexical effect handlers often ignores this issue. For
example, Xie et al. \cite{xie2020effect} proposed a system which only
supported directly nesting effect handlers and had no mechanism for
writing a composable handler for generators that could be moved between
different underlying asynchronous I/O handlers.

This is because this composition requiring forwarding is much less
common than nesting and it fundamentally requires each use of the
\lstinline[style=oxcaml]{Await} operation to perform work proportional to
the number of handlers it is forwarded through -- often referred to as a
``linear search''. There has been a tendency to treat this linear search
as some form of deficiency of algebraic effect handlers, but it is
simply a classic trade-off between the extra expressivity allowed by an
indirection and the runtime cost of traversing that indirection. With
our effect reflection API we are able to use nesting for the cases that
it supports -- avoiding the cost of the indirection -- and fall back to
forwarding for the more general cases.

\subsection{Parameterized effects and handlers}

The state handlers in this paper so far have all been restricted to
\lstinline[style=oxcaml]{int} state. This is a limitation of the effect
reflection API that we have been using. We would like to support
\emph{parameterized effects} -- allowing a single handler to be used
with a whole family of effects. For example, a state handler
parameterized by the type of the state.

We can support parameterized effects by adding a module type for them,
along with parameterized versions of \lstinline[style=oxcaml]{Term} and
\lstinline[style=oxcaml]{Handler}:
\begin{lstlisting}[style=oxcaml]
module type Op1 = sig type ('a, 'e) t end

module Term1 (O : Op1) : sig
  type ('a, 'e) t =
    | Return : 'a @@ global -> 'a t
    | Op : ('r, 'e) O.t @@ global * ('r -> 'a t) -> 'a t
end

module Handler1(O : Op1) : sig
  type 'e t
end
\end{lstlisting}
with a corresponding parameterized version of
\lstinline[style=oxcaml]{Reflection}. We can then define a parameterized
state effect:
\begin{lstlisting}[style=oxcaml]
module State = struct
  type ('a, 'b) t =
    | Get : 'b t
    | Set : 'b -> unit t
end
\end{lstlisting}
and write a handler that provides a parameterized interface for the
state effect:
\begin{lstlisting}[style=oxcaml]
type 's handler

val handle : ('s handler @ local -> 'a) @ local -> 's -> 'a
val get : 's handler @ local -> 's
val set : 's handler @ local -> 's -> unit
\end{lstlisting}

The need for a new copy of the interface for each type constructor arity
is an artefact of OCaml's approach to higher-kinded types. Languages
with direct support for higher-kinded types should be able to support
parameterized effects of arbitrary arity with a single interface.

\section{A language with effect reflection}
\label{sec:language}

The design of effect reflection falls out naturally from a semantics in
terms of presheaves. To illustrate this semantics we first build a
simple language with effect reflection.

\subsection{The standard parts}

Our language is simply typed, featuring all the usual type-formers. It
uses a variation of fine-grained call-by-value: it has separate syntax
and typing judgements for values and computations. The syntax and typing
rules for these standard parts of the language are shown in
Fig.\ref{fig:typing-standard}, and there isn't much interesting to say
about them.
\begin{figure}
\begin{align*}
  \mathrm{types}, \tau ::=\;& \tau \times \tau \mid 1 \mid \tau + \tau
                              \mid \tau \rightarrow \tau \mid \ldots \\
  \mathrm{contexts}, \Gamma ::=\;& \cempty \mid \lbind{\Gamma}{x}{\tau} \mid \ldots \\
  \mathrm{values}, v :=\;& x \mid (v, v) \mid \fst v \mid \snd v
                           \mid () \mid \inl{v} \mid \inr{v} \mid \abs{x}{\tau}{c} \mid \ldots \\
  \mathrm{computations}, c :=\;& \return{v} \mid \letv{x}{c}{c}
                                 \mid \app{v}{v} \mid \\
                            & \case{v}{x}{c}{x}{c} \mid \ldots
\end{align*}
\begin{mathpar}
\inferrule{\\}
{\lbind{\Gamma}{x}{\tau} \turnv x \types \tau}
\and
\inferrule{\Gamma \turnv v_1 \types \tau_1 \\ \Gamma \turnv v_1 \types \tau_1}
{\Gamma \turnv (v_1, v_2) \types \tau_1 \times \tau_2}
\and
\inferrule{\Gamma \turnv v \types \tau_1 \times \tau_2}
{\Gamma \turnv \fst{v} \types \tau_1}
\and
\inferrule{\Gamma \turnv v \types \tau_1 \times \tau_2}
{\Gamma \turnv \snd{v} \types \tau_2}
\and
\inferrule{\\}
{\Gamma \turnv () \types 1}
\and
\inferrule{\Gamma \turnv v \types \tau_1}
{\Gamma \turnv \inl{v} \types \tau_1 + \tau_2}
\and
\inferrule{\Gamma \turnv v \types \tau_2}
{\Gamma \turnv \inr{v} \types \tau_1 + \tau_2}
\and
\inferrule{\lbind{\Gamma}{x}{\tau_1} \turnc c \types \tau_2}
{\Gamma \turnv \abs{x}{\tau_1}{c} \types \tau_1 \rightarrow \tau_2}
\and
\inferrule{\Gamma \turnv v \types \tau}
{\Gamma \turnc \return{v} \types \tau}
\and
\inferrule{\Gamma \turnc c_1 \types \tau_1 \\
           \lbind{\Gamma}{x}{\tau_1} \turnc c_2 \types \tau_2}
{\Gamma \turnc \letv{x}{c_1}{c_2} \types \tau_2}
\and
\inferrule{\Gamma \turnv v_1 \types \tau_1 \rightarrow \tau_2 \\
           \Gamma \turnv v_2 \types \tau_1}
{\Gamma \turnc v_1 v_2 \types \tau_2}
\and
\inferrule{\Gamma \turnv v \types \tau_1 + \tau_2 \\
           \lbind{\Gamma}{x_1}{\tau_1} \turnc c_1 \types \tau_3 \\
           \lbind{\Gamma}{x_2}{\tau_2} \turnc c_2 \types \tau_3}
{\Gamma \turnc \case{v}{x_1}{c_1}{x_2}{c_2} \types \tau_3}
\end{mathpar}
\caption{Standard syntax and typing rules}
\label{fig:typing-standard}
\end{figure}

\subsection{Locality}

We track locality in the language via a global comonadic modality
$\glob$. In our setting being global means not depending on the ambient
monad. For example, the function type $1 \rightarrow 1$ represents
computations in the ambient monad -- e.g. if the ambient monad includes
state then such a function may mutate that state -- whereas the global
function type $\glob (1 \rightarrow 1)$ has only a single value: the
function that does nothing and returns $()$.

When using $\gbox{v}$ to build a value with a global type, we can only
use existing values that also have a global type. We achieve this using
a fairly standard approach for modal types: we extend contexts with a
binding form that requires a global type and then we restrict the
context in which we type $v$ to only include such bindings. The new
global binding form is written $\gbind{\Gamma}{x}{\tau}$ and represents
a value in the context of type $\glob \tau$. We create global bindings
in the context using the elimination form: $\gunbox{x}{v_1}{v_2}$.

Restricting the context is implemented via an operation on contexts
$\cdiv{\Gamma}$ that removes all local bindings, leaving only the global
ones:
\begin{align*}
  &\cdiv{\cempty} = \cempty \\
  &\cdiv{(\lbind{\Gamma}{x}{\tau})} = \cdiv{\Gamma} \\
  &\cdiv{(\gbind{\Gamma}{x}{\tau})} = \gbind{\cdiv{\Gamma}}{x}{\tau}
\end{align*}

Global computations do not depend on the ambient monad, so we also
include a value form $\grun{c}$, which allows treating a global
computation $c$ as a value.

The syntax and typing rules related to locality are in
Fig.\ref{fig:typing-locality}
\begin{figure}
\begin{align*}
  \mathrm{types}, \tau ::=\;& \ldots \mid \glob \tau \mid \ldots \\
  \mathrm{contexts}, \Gamma ::=\;& \ldots \mid \gbind{\Gamma}{x}{\tau} \\
  \mathrm{values}, v :=\;& \ldots \mid \gbox{v} \mid \gunbox{x}{v}{v}
                           \mid \grun{c} \mid \ldots
\end{align*}
\begin{mathpar}
\inferrule{\\}
{\gbind{\Gamma}{x}{\tau} \turnv x \types \tau}
\and
\inferrule{\cdiv{\Gamma} \turnv v \types \tau}
{\Gamma \turnv \gbox{v} \types \glob \tau}
\and
\inferrule{\Gamma \turnv v_1 \types \glob \tau_1 \\
           \gbind{\Gamma}{x}{\tau_1} \turnv v_2 \types \tau_2}
{\Gamma \turnv \gunbox{x}{v_1}{v_2} \types \tau_2}
\and
\inferrule{\cdiv{\Gamma} \turnc c \types \tau}
{\Gamma \turnv \grun{c} \types \tau}
\end{mathpar}
\caption{Locality syntax and typing rules}
\label{fig:typing-locality}
\end{figure}

\subsection{Signatures and inductive types}

Effect reflection requires, for any signature $\Sigma$ that is being
reflected, an inductive type $\ind{\Sigma}$ to represent the free
algebra of $\Sigma$. $\ind{\Sigma}$ is sometimes called the \emph{freer
  monad} of $\Sigma$ \cite{kiselyov2015freer}.

As with other algebraic effects systems in the literature, we only
support handlers for algebraic theories without any equations, even
though our semantics is defined in terms of arbitrary theories. We
define algebraic signatures $\Sigma$ as finite sets of operations:
\begin{equation*}
\{ op_1 \types \tau_{p_1} \rightarrowtail \tau_{a_1}; \ldots; op_n
\types \tau_{p_n} \rightarrowtail \tau_{a_n} \}
\end{equation*}
An operation type $\tau_p \rightarrowtail \tau_a$ indicates an operation
parameterized by $\tau_p$ and with arity $\tau_a$.

\begin{example}
  The signature for boolean state, which we'll call $\Sigma_{bs}$
  is:
  \begin{equation*}
    \{ \mathrm{get} \types 1 \rightarrowtail (1 + 1);
       \mathrm{set} \types (1 + 1) \rightarrowtail 1 \}
  \end{equation*}
\end{example}

We also allow the sum of two signatures $\Sigma_1 + \Sigma_2$ to be used
as a signature. It has operations:
\begin{align*}
\{ \; &\mathrm{left}(op_{1,1}) \types \tau_{p_{1,1}} \rightarrowtail \tau_{a_{1,1}} \seq
        \ldots \seq
        \mathrm{left}(op_{1, n}) \types \tau_{p_{1, n}} \rightarrowtail \tau_{a_{1, n}} \\
      &\mathrm{right}(op_{2, 1}) \types \tau_{p_{2, 1}} \rightarrowtail \tau_{a_{2,1}} \seq
        \ldots \seq
        \mathrm{right}(op_{2, m}) \types \tau_{p_{2, m}} \rightarrowtail \tau_{a_{2, m}}
        \; \}
\end{align*}
where $op_{1,1} \seq \ldots \seq op_{1,n}$ are the operations of
$\Sigma_1$ and $op_{2,1} \seq \ldots \seq op_{2,m}$ are the operations
of $\Sigma_2$.

For each operation $op \types \tau_p \rightarrowtail \tau_a$,
$\ind{\Sigma}(\tau)$ has a constructor $\indintro{\Sigma}{op}{v_p}{v_k}$
where $v_p \types \tau_p$ and
$v_k \types \tau_a \rightarrow \ind{\Sigma}(\tau)$. $\ind{\Sigma}(\tau)$
also has a constructor $\ret{\Sigma}{v}$ where $v \types \tau$.

The eliminator for $\ind{\Sigma}$ is written
\begin{align*}
\indelim{\Sigma}{v}
  {&\indretcase{x}{c_r} \seq \\
   &\indcase{op_1}{x_{p_1}}{x_{k_1}}{c_1} \seq \\
   &\ldots \seq \\
   &\indcase{op_n}{x_{p_n}}{x_{k_n}}{c_n}}
\end{align*}
The syntax and typing rules for inductive types are shown in
Fig.\ref{fig:typing-inductive}.

\begin{figure}
\begin{align*}
  \mathrm{types}, \tau ::=\;& \ldots \mid \ind{\Sigma}(\tau) \mid \ldots \\
  \mathrm{signatures}, \Sigma ::=\;& \{ op \types \tau \rightarrowtail \tau \seq \ldots
                                       \seq op \types \tau \rightarrowtail \tau \}
                                     \mid \Sigma + \Sigma \\
  \mathrm{values}, v :=\;& \ldots \mid \indintro{\Sigma}{op}{v}{v}
                           \mid \ret{\Sigma}{v} \mid \ldots \\
  \mathrm{computations}, c :=\;& \ldots \mid \indelim{\Sigma}{v}
                                 {\indretcase{x}{c} \seq
                                 \indcase{op}{x}{x}{c} \seq \ldots
                                 \seq \indcase{op}{x}{x}{c}} \mid \ldots
\end{align*}
\begin{mathpar}
\inferrule{op \types \tau_1 \rightarrowtail \tau_2 \in \Sigma \\
           \Gamma \turnv v_1 \types \glob \tau_1 \\
           \Gamma \turnv v_2 \types \glob \tau_2 \rightarrow \ind{\Sigma}(\tau)}
{\Gamma \turnv \indintro{\Sigma}{op}{v_1}{v_2} \types \ind{\Sigma}(\tau)}
\and
\inferrule{\Gamma \turnv v \types \tau}
{\Gamma \turnv \ret{\Sigma}{v} \types \ind{\Sigma}(\tau)}
\and
\inferrule{\Gamma \turnv v \types \ind{\Sigma}(\tau_1) \\
           \Sigma = \{ op_1 \types \tau_{p_1} \rightarrowtail \tau_{a_1};
             \ldots; op_n\types \tau_{p_n} \rightarrowtail \tau_{a_n} \} \\
           \lbind{\Gamma}{x_r}{\tau_1} \turnc c_r \types \tau_2 \\
           \lbind{\lbind{\Gamma}{x_{p_1}}{\glob \tau_{p_1}}}{x_{k_1}}{\glob \tau_{a_1} \rightarrow \tau_2} \turnc c_1 \types \tau_2 \\
           \ldots \\
           \lbind{\lbind{\Gamma}{x_{p_n}}{\glob \tau_{p_n}}}{x_{k_n}}{\glob \tau_{a_n} \rightarrow \tau_2} \turnc c_n \types \tau_2}
{\Gamma \turnc \indelim{\Sigma}{v}{\indretcase{x_r}{c_r} \seq
                                   \indcase{op_1}{x_{p_1}}{x_{k_1}}{c_1} \seq \ldots \seq
                                   \indcase{op_n}{x_{p_n}}{x_{k_n}}{c_n}} \types \tau_2}
\end{mathpar}
\caption{Inductive type syntax and typing rules}
\label{fig:typing-inductive}
\end{figure}

\begin{example}
  \label{example:negate}
  The following value of type $\ind{\Sigma_{bs}}$ represents a
  reified computation that negates the value of the state:
  \begin{align*}
    &\indintro{\Sigma_{bs}}{get}{()}{\abs{x_a}{1 + 1}{\\
        &\qquad \letv{x_n}{\app{\mathit{negate}}{x_a}}{\\
          &\qquad \indintro{\Sigma_{bs}}{set}{x_n}{\abs{x_u}{1}{\ret{\Sigma_{bs}}{x_u}}}}}}
  \end{align*}
  where $\mathit{negate}$ is the function that negates a boolean.
\end{example}

\subsection{Effect reflection}

The language provides a type $\yoneda{\Sigma}$ for each $\Sigma$ to
represent mappings from the operations of $\Sigma$ into the current
ambient monad. Effect reflection appears in the language as two
operations: reflection and reification. Reflection
$\reflectraw{\Sigma}{op}$ uses a value of type $\yoneda{\Sigma}$ to map
the operation $op$ from $\Sigma$ into the ambient monad.  Reification
$\reifyraw{\Sigma}$ extends the ambient monad with the operations from
$\Sigma$, providing a value of type $\yoneda{\Sigma}$ for constructing
those operations via reflection. Their syntax and typing rules are shown
in Fig.\ref{fig:typing-reflection}.

\begin{figure}
\begin{align*}
  \mathrm{types}, \tau ::=\;& \ldots \mid \yoneda{\Sigma} \mid \ldots \\
  \mathrm{values}, v :=\;& \ldots \mid \outl{v} \mid \outr{v} \\
  \mathrm{computations}, c :=\;& \ldots \perform{v}{op}{v}{x}{c} \mid \reify{\Sigma}{x}{c}
\end{align*}
\begin{mathpar}
\inferrule{\Gamma \turnv v \types \yoneda{\Sigma_1 + \Sigma_2}}
{\Gamma \turnv \outl{v} \types \yoneda{\Sigma_1}}
\and
\inferrule{\Gamma \turnv v \types \yoneda{\Sigma_1 + \Sigma_2}}
{\Gamma \turnv \outr{v} \types \yoneda{\Sigma_2}}
\and
\inferrule{\Gamma \turnv v_1 \types \yoneda{\Sigma} \\
           op \types \tau_1 \rightarrowtail \tau_2 \in \Sigma \\
           \Gamma \turnv v_2 \types \glob \tau_1 \\
           \lbind{\Gamma}{x}{\glob \tau_2} \turnc c \types \tau_3}
{\Gamma \turnc \; \perform{v_1}{op}{v_2}{x}{c} \types \tau_3}
\and
\inferrule{\lbind{\Gamma}{x}{\yoneda{\Sigma}} \turnc c \types \glob \tau}
{\Gamma \turnc \; \reify{\Sigma}{x}{c} \types \ind{\Sigma}(\glob \tau)}
\end{mathpar}
\caption{Effect reflection syntax and typing rules}
\label{fig:typing-reflection}
\end{figure}

Note that we treat reflection of individual operations
$\performraw{v}{op}$ as primitive. We can define reflection of
terms $\reflectraw{\Sigma}$ in terms of $\performraw{v}{op}$:
\begin{align*}
    \reflect{\Sigma}{v}{c} := \quad &\letv{x_w}{c}{\\
        &\indelim{\Sigma}{x_w}{ \\
        &\qquad \indretcase{x_r}{\return{x_r}} \seq \\
        &\qquad \indcase{op_1}{x_{p_1}}{x_{k_1}}
          {\perform{v}{op_1}{x_{p_1}}{x_{a_1}}{(\app{x_{k_1}}{x_{a_1}})}} \seq \\
        &\qquad \ldots \seq \\
        &\qquad \indcase{op_n}{x_{p_n}}{x_{k_n}}
          {\perform{v}{op_n}{x_{p_n}}{x_{a_n}}{(\app{x_{k_n}}{x_{a_n}})}}}}
\end{align*}
which has this admissible typing rule:
\begin{mathpar}
\inferrule{\Gamma \turnv v \types \yoneda{\Sigma} \\
           \Gamma \turnv c \types \ind{\Sigma}(\glob \tau)}
{\Gamma \turnc \; \reflect{\Sigma}{v}{c} \types \glob \tau}
\end{mathpar}

We also provide projections $\outl$ and $\outr$ that decompose a mapping
for $\Sigma_1 + \Sigma_2$ into mappings for $\Sigma_1$ and $\Sigma_2$
respectively.

\begin{example}
  The value from Example~\ref{example:negate} can be constructed via reflection as:
  \begin{align*}
    &\reify{\Sigma_{bs}}{x_h}{\\
      &\qquad \perform{x_h}{get}{()}{x_a}{\\
        &\qquad \qquad \letv{x_n}{\app{\mathit{negate}}{x_a}}{\\
          &\qquad \qquad \perform{x_h}{set}{x_n}{x_u}{\return{x_u}}}}}
  \end{align*}
  where $\mathit{negate}$ is the function that negates a boolean.
\end{example}


\subsection{Operational semantics}
\label{sec:operational}

We define the operational semantics as a pair of mutually defined
reduction relations $\reducestov$ and $\reducestoc$ for values and
computations respectively shown in Fig.\ref{fig:reduction}. The
definitions of normal forms for values and computations are given in
Fig.\ref{fig:normal}. Subject reduction and strong normalization of
these rules can be proved using standard techniques.

\begin{figure}
\begin{align*}
\fst{(v_1, v_2)} &\reducestov v_1 \\
\snd{(v_1, v_2)} &\reducestov v_2 \\
\gunbox{x}{\gbox{v_1}}{v_2} &\reducestov \sbst{v_2}{x}{v_1} \\
\grun{\return{v}} &\reducestov v \\
\letv{x}{\return{v}}{c} &\reducestov \sbst{c}{x}{v} \\
\letv{x_1}{\perform{v_1}{op}{v_2}{x_2}{c_1}}{c_2} &\reducestov \perform{v_1}{op}{v_2}{x_2}{\letv{x_1}{c_1}{c_2}} \\
\app{(\abs{x}{\tau}{c})}{v} &\reducestoc \sbst{c}{x}{v} \\
\case{(\inl{v})}{x_1}{c_1}{x_2}{c_2} &\reducestoc \sbst{c_1}{x_1}{v} \\
\case{(\inr{v})}{x_1}{c_1}{x_2}{c_2} &\reducestoc \sbst{c_2}{x_2}{v} \\
\indelim{\Sigma}{(\ret{\Sigma}{v})}{\indretcase{x}{c} \seq \ldots} &\reducestoc \sbst{c}{x}{v} \\
\indelim{\Sigma}{\indintro{\Sigma}{op}{v_1}{v_2}}{H_1 \seq \indcase{op}{x_1}{x_2}{c} \seq H_2} \\
  \reducestoc \sbst{\sbst{c}{x_1}{v_1}}{x_2}{\abs{x_a}{\tau_a}{&\letv{x_w}{\app{v_2}{x_a}}{\indelim{\Sigma}{x_w}{H_1 \seq \indcase{op}{x_1}{x_2}{c} \seq H_2}}}} \\
\reify{\Sigma}{x}{\return{v}} &\reducestoc \return{\ret{\Sigma}{v}} \\
\reify{\Sigma}{x_1}{\perform{x_1}{op}{v}{x_2}{c}} &\reducestoc \return{\indintro{\Sigma}{op}{v}{\abs{x_2}{\reify{\Sigma}{x_1}{c}}}} \\
\reify{\Sigma}{x_1}{\perform{x_2}{op}{v}{x_3}{c}} &\reducestoc \perform{x_2}{op}{v}{x_3}{\reify{\Sigma}{x_1}{c}} \qquad (x_1 \neq x_2) \\
\perform{(\outl{v_1})}{op}{v_2}{x}{c} &\reducestoc \perform{v_1}{\mathrm{left}(op)}{v_2}{x}{c} \\
\perform{(\outr{v_1})}{op}{v_2}{x}{c} &\reducestoc \perform{v_1}{\mathrm{right}(op)}{v_2}{x}{c}
\end{align*}
\caption{Reduction relations}
\label{fig:reduction}
\end{figure}
\begin{figure}
\begin{align*}
  \mathrm{neutral\ values}, \eta :=\;& x \mid \fst \eta \mid \snd \eta
                                     \mid \gunbox{x}{\eta}{\omega} \mid \grun{\mu} \\
  \mathrm{neutral\ computations}, \mu :=\;& \letv{x}{\mu}{\gamma}
                                           \mid \app{\eta}{\omega} \mid \\
                                   & \case{\eta}{x}{\gamma}{x}{\gamma} \mid \\
                            & \indelim{\Sigma}{\eta}
                              {\indretcase{x}{\gamma} \seq
                               \indcase{op}{x}{x}{\gamma} \seq \ldots \seq
                               \indcase{op}{x}{x}{\gamma}} \\
                                   & \reify{\Sigma}{x}{\mu} \\
  \mathrm{normal\ values}, \omega :=\;& \eta \mid (\omega, \omega)
                           \mid () \mid \inl{\omega} \mid \inr{\omega} \mid \abs{x}{\tau}{\gamma} \mid \\
                           &\indintro{\Sigma}{op}{\omega}{\omega} \mid \ret{\Sigma}{\omega} \mid \\
                           &\gbox{\omega} \mid \outl{\omega} \mid \outr{\omega} \\
  \mathrm{normal\ computations}, \gamma :=\;& \mu \mid \return{\omega}
                                               \mid \perform{\eta}{op}{\omega}{x}{\gamma}
\end{align*}
\caption{Normal forms}
\label{fig:normal}
\end{figure}

Note that the reduction relations do not include $\eta$ expansion. They
also do not include some conversions you might expect for computations:
\begin{itemize}
\item There is no rule to convert
  $\; \letv{x_2}{\letv{x_1}{c_1}{c_2}}{c_3} \,$ to
  $\; \letv{x_1}{c_1}{\letv{x_2}{c_2}{c_3}} \,$ or vice versa.
\item There is no rule to convert $\; \letv{x}{c}{\return x} \,$ to $c$.
\end{itemize}
These rules are excluded because they are not $\beta$ rules. Instead
they are better thought of as $\nu$ rules \cite{allais2013new}:
additional equalities between neutral terms that are immediate
consequences of structural induction. Rather than be included as part of
ordinary reduction they can be done as an additional standardization
pass on neutral terms after reduction and $\eta$-expansion have
completed. This staged approach to computing equality of terms works
because $\nu$ rules cannot produce additional $\beta$ redexes.

\subsection{Embedding the Simply-Typed Lambda Calculus}

Using the global modality and $\grun{c}$ construct we can embed the
Simply Typed Lambda Calculus (STLC) into this language as values. We
define an embedding $\embed{\_}$ on types, contexts and terms of STLC in
Fig.\ref{fig:stlc}. Note that $\reducestov$ matches the behaviour of
$\beta$ reduction of STLC too, with each STLC reduction step
corresponding to up to 3 steps of $\reducestov$.
\begin{figure}
\begin{equation*}
\begin{aligned}[c]
  &\embed{1} = 1 \\
  &\embed{A \times B} = \embed{A} \times \embed{B} \\
  &\embed{A \rightarrow B} = (\glob \embed{A}) \rightarrow \embed{B} \\ \\
  &\embed{\cempty} = \cempty \\
  &\embed{\lbind{\Gamma}{x}{A}} = \gbind{\embed{\Gamma}}{x}{\embed{A}}
\end{aligned}
\qquad
\begin{aligned}[c]
  &\embed{x} = x \\
  &\embed{(e, f)} = (\embed{e}, \embed{f}) \\
  &\embed{\fst{e}} = \fst{\embed{e}} \\
  &\embed{\snd{e}} = \snd{\embed{e}} \\
  &\embed{\abs{x}{A}{e}} =
    \abs{x^{\prime}}{\glob \embed{A}}{\return{(\gunbox{x}{x^{\prime}}{\embed{e}})}} \\
  &\embed{\app{f}{e}} = \grun{\app{\embed{f}}{(\gbox{\embed{e}})}}
\end{aligned}
\end{equation*}
\caption{Embedding of Simply-Typed Lambda Calculus into values}
\label{fig:stlc}
\end{figure}

\section{Presheaves for algebraic effects}
\label{sec:semantics}

The design of effect reflection falls out naturally from a simple
denotational semantics built on presheaves. The key idea is to index the
meaning of types by an ambient algebraic monad of effects: rather than
have the semantics of each type be a set of elements, the semantics of
each type is a mapping from the ambient monad to a set of elements.

\subsection{Algebraic monads}

In order to index the meaning of our types by the ambient monad we need
some way of representing that ambient monad. As with all approaches to
algebraic effects, we must restrict ourselves to monads that have some
nice properties, in particular we need the sum of two of these monads to
always exists.

To this end, we will restrict the ambient monad to be an \emph{algebraic
  monad}: one that can be expressed as the free algebras of an algebraic
theory. Note that this definition of algebraic monad is not precise:
different choices for the definition of ``algebraic theory'' give you
different meanings for ``algebraic monad''. We'll make our particular
choice over the course of this section.

We recall the definitions of algebraic signature, terms of a signature,
algebraic theory and models of a theory.
\begin{definition}[Algebraic signature]
  An \emph{algebraic signature} is a set of operations with associated
  arities.
\end{definition}

\begin{example}
  The algebraic signature for boolean state is:
  \begin{equation*}
    \{ (\mathrm{get}, 2); (\mathrm{set\_true}, 1); (\mathrm{set\_false}, 1) \}
  \end{equation*}
\end{example}

\begin{definition}[Term]
  A \emph{term} $t$ of some algebraic signature $\Sigma$ is either a
  free variable $x$ or $op(t_1, \ldots, t_k)$ where $op$ is an operation
  of $\Sigma$ with arity $k$ and each $t_i$ is itself a term.
\end{definition}

\begin{definition}[Algebraic theory]
  An \emph{algebraic theory} consists of an algebraic signature $\Sigma$ and a set of
  equations on terms of $\Sigma$.
\end{definition}

\begin{example}
  The algebraic theory for boolean state adds the following equations to
  the signature of boolean state:
  \begin{align*}
    &\mathrm{set\_true}(\mathrm{get}(x, y)) = \mathrm{set\_true}(x)
    &\mathrm{set\_false}(\mathrm{get}(x, y)) = \mathrm{set\_false}(y) \\
    &\mathrm{set\_true}(\mathrm{set\_true}(x)) = \mathrm{set\_true}(x)
    &\mathrm{set\_true}(\mathrm{set\_false}(x)) = \mathrm{set\_false}(x) \\
    &\mathrm{set\_false}(\mathrm{set\_true}(x)) = \mathrm{set\_true}(x)
    &\mathrm{set\_false}(\mathrm{set\_false}(x)) = \mathrm{set\_false}(x) \\
    &\mathrm{get}(\mathrm{set\_true}(x), \mathrm{set\_false}(x))) = x
  \end{align*}
\end{example}

\begin{definition}[Model]
  A \emph{model} $M$ of some algebraic theory $L$ consists of a carrier
  set $S$ and for each operation $op$ in the signature of $L$ a function
  $op_M : (\Pi_k S) \rightarrow S$ where $k$ is the arity of $op$, such
  that the equations of $L$ are respected when interpreting the terms
  using these functions for the operations. Models of $L$ are also
  called algebras of $L$.
\end{definition}

\begin{example}
  We can model the theory of boolean state using the carrier set
  $2 \rightarrow 2$ and interpreting the operations with:
  \begin{align*}
    &\mathrm{get}(x, y) = \lambda s.\, \mif s \mthen x(s) \melse y(s) \\
    &\mathrm{set\_true}(x) = \lambda s.\, x(\mathrm{true}) \\
    &\mathrm{set\_false}(x) = \lambda s.\, x(\mathrm{false})
  \end{align*}
\end{example}

Arities in algebraic signatures are often considered as natural numbers,
but they can equivalently be just sets, with families of terms indexed
by that set used as the arguments of that operator in a term. It is also
convenient to allow families of operations parameterized by some set. As
such, we can present a signature in the form:
\begin{equation*}
\{ op_1 \types P_1 \rightarrowtail A_1; \ldots; op_n
\types P_n \rightarrowtail A_n \}
\end{equation*}
where $op \types P \rightarrowtail A$ indicates an operation $op$
parameterized by $P$ and with arity $A$.

\begin{example}
  The algebraic signature for boolean state can be written as:
  \begin{equation*}
    \{ \mathrm{get} \types 1 \rightarrowtail 2; \mathrm{set} \types 2 \rightarrowtail 1 \}
  \end{equation*}
\end{example}

Given a Lawvere theory $L$ and a set $A$ we can construct the free
model, or \emph{free algebra}, $T_L(A)$. The values $T_L(A)$ are terms
built using the elements of $A$ and the operations of $L$ quotiented by
the equations in $L$. $T_L$ is a monad and $T$ is one half of an
equivalence between algebraic theories and algebraic monads.

\begin{example}
  The free algebras of the theory of boolean state are equivalent
  to the type:
  \begin{lstlisting}[style=oxcaml]
  type 'a t =
    | Return of 'a
    | Get of unit * (bool -> 'a t)
    | Set of bool * (unit -> 'a t)
  \end{lstlisting}
  and they form a monad:
  \begin{lstlisting}[style=oxcaml]
  let return x = Return x
  let rec bind x f =
    match x with
    | Return x -> f x
    | Get((), k) -> Get((), (fun s -> bind (k s) f))
    | Set(s, k) -> Set(s, (fun () -> bind (k ()) f))
  \end{lstlisting}  
\end{example}

Traditionally, algebraic signatures are restricted to the case of a
finite set of operations each with a finite arity. Most theoretical work
in the algebraic effects literature extends this to the case of
countable sets of operations with countable arities, which allows us to
construct the signature for natural number state:

\begin{example}
  The algebraic signature for natural number state is:
  \begin{equation*}
    \{ \mathrm{get} \types 1 \rightarrowtail \nat;
       \mathrm{set} \types \nat \rightarrowtail 1 \}
  \end{equation*}
\end{example}

However, this extension is not sufficient to construct the signature for
state containing a function $\nat \rightarrow \nat$. For that we must
extend algebraic signatures further to allow for arbitrary sets of
operations with arbitrary sets as arities. Such algebraic theories are
called \emph{bounded infinitary algebraic theories} because for each
such theory there is some regular cardinal $\kappa$ that is a bound on
the arities of the theory. An algebraic theory with some bound $\kappa$
corresponds to a monad with rank $\kappa$. Thus we take monads with a
rank as our precise definition of algebraic monad.

Most monads used in practice for programming are algebraic by this
definition, with the notable exception of the continuation monad. The
issue with trying to represent non-algebraic monads algebraically is
essentially one of size: if you try to write down the collection of
algebraic operations for the continuation monad you get something that
is too large to be a set. This is closely related to the strict
positivity restriction on inductive type definitions.

\subsection{(Bounded) Lawvere theories}

We use \emph{Lawvere theories} as our concrete representation of the
ambient algebraic monad. Lawvere theories are a categorical
representation of algebraic theories that doesn't depend on the
particular choice of operations and equations.

\begin{definition}
  A \emph{Lawvere theory} is a category $L$ with finite products in
  which every object is isomorphic to some finite cartesian product
  $x^n = x \times \ldots \times x$ of a distinguished object $x$.
\end{definition}
The objects of a Lawvere theory correspond to the different possible
arities and the morphisms $x^n \rightarrow x$ correspond to terms
of $L$ with $n$ free variables quotiented by the equations in $L$. A
model of a Lawvere theory $L$ is a product-preserving functor
$L \rightarrow \setc$.

Lawvere theories correspond to the traditional for of algebraic
theories: those with a finite set of operations with finite arities, but
we can extend the definition to get something that corresponds to
\emph{bounded infinitary algebraic theories}.
\begin{definition}
  A \emph{Bounded Lawvere theory} is a small category $L$ with small
  products in which every object is isomorphic to some small cartesian
  product $\Pi_S x$ of a distinguished object $x$.
\end{definition}
Note that the ``bounded'' aspect of the definition comes from the
restriction that the category be small.

We will mostly describe Lawvere theories and constructions on them in
terms of their presentations as algebraic theories, so an understanding
the details of Lawvere theories is not required for understanding the
rest of this paper.

Bounded Lawvere theories form a category $\lawc$ whose morphisms are
equivalent to maps from the operations of one theory to the operations
of another that preserve the equations of the first theory according to
the equations of the second.

$\lawc$ has an initial object $\initial$, which is the algebraic theory
with no operations. It also has coproducts $L + M$ which is the theory
made by unioning the operations and equations of $L$ and $M$.

\subsection{Presheaves}

For a category $\cat$, $\psh = \setc^{\catop}$ is the category of
presheaves over $\cat$. It's objects are contravariant functors from
$\cat$ to $\setc$ and it's morphisms are natural transformations between
such functors.

A common use of presheaves is where $\cat$ has finite products and is
thought of as some form of context over which everything is
parameterized. In our case we wish to be parameterized by a context of
\emph{algebraic theories that can be mapped into the ambient
  monad}. Note that the algebraic theories in such a context are
\emph{contravariant}: they describe theories that can be handled by the
ambient monad. As such, we use
\begin{equation*}
  \pshlawcop = \setc^{\lawc}
\end{equation*}
as the basis of our semantics. The $\op$ in the definition of presheaves
and the $\op$ due to our dependence being contravariant cancel out, but
it is still best to think in terms of presheaves as that is a more
precise description of what we are doing.

Our semantics will use objects from $\pshlawcop$ to represent types and
contexts, and morphisms in $\pshlawcop$ to represent values. This allows
their meanings to be parameterized by the ambient monad. By using
presheaves rather than ordinary functions we ensure terms and types at a
particular ambient monad can always be mapped naturally to a larger
ambient monad.

\begin{equation*}
\sem{\tau} \mathrel{:} \pshlawcop \qquad
\sem{\Gamma} \mathrel{:} \pshlawcop \qquad
\sem{\Gamma \turnv v \types \tau} \mathrel{:} \homset{\pshlawcop}{\sem{\Gamma}}{\sem{\tau}}
\end{equation*}

Categories of presheaves have products and coproducts, which are defined
pointwise. We will use these as the semantics of product types and sum
types.
\begin{align*}
&\sem{1} = 1 \\
&\sem{\tau_1 \times \tau_2} = \sem{\tau_1} \times \sem{\tau_2} \\
&\sem{\tau_1 + \tau_2} = \sem{\tau_1} + \sem{\tau_2} \\
\end{align*}
The semantics of the corresponding introduction and elimination forms
follows the usual categorical semantics of such types.

We also use products for the semantics of contexts:
\begin{align*}
&\sem{\cempty} = 1 \\
&\sem{\lbind{\Gamma}{x}{\tau}} = \sem{\Gamma} \times \sem{\tau} \\
\end{align*}

\subsection{Representing computations: The free algebras monad}

Our aim is to have a semantics where the meaning of types is indexed by
the ambient monad -- or more precisely by the algebraic theory whose
free algebras are the ambient monad. In particular, we would like the
interpretation of types of computations to be applications of the
ambient monad.

Given a Lawvere theory $L$, the underlying set of its free algebras form
a monad $T_L$ on $\setc$. In addition to the unit of the monad, we can
construct elements of $T_L$ using the operations of $L$. For an
operation $op \types P \rightarrowtail A$ of a Lawvere theory $L$ and
some set $S$, there is a function
$op_{T_L} \types (P \times (A \rightarrow T_L(S))) \rightarrow T_L(S)$
that constructs terms in the free algebra using $op$.

$T_{\_}$ is functorial and we can use it to construct a monad $\mon$ on
$\pshlawcop$ such that:
\begin{equation*}
\mon(P)(L) = T_L(P(L))
\end{equation*}
We call $\mon$ the \emph{free algebras monad}, and we will use it as the
computation monad in our denotational semantics.
\begin{align*}
  &\sem{\Gamma \turnc v \types \tau} \mathrel{:}
    \homset{\pshlawcop}{\sem{\Gamma}}{\mon(\sem{\tau})} \\
  &\sem{\Gamma \turnc \return{v} \types \tau} =
    \eta_{\sem{\tau}} \circ \sem{\Gamma \turnv v \types \tau} \\
  &\sem{\Gamma \turnc \letv{x}{c_1}{c_2} \types \tau_2} =
    \mu_{\sem{\tau_2}}
    \circ \mon(\sem{\lbind{\Gamma}{x}{\tau_1} \turnc c_2 \types \tau_2})
    \circ t_{\sem{\Gamma}, \sem{\tau_1}}
    \circ \langle id_{\sem{\Gamma}}, \sem{\Gamma \turnc c_1 \types \tau_1} \rangle
\end{align*}
where $\eta$, $\mu$ and $t$ are the unit, multiplication and strength
respectively of $\mon$.

Categories of presheaves also have exponentials, which combine with the
free algebras monad to give us our semantics for function types.
\begin{align*}
  &\sem{\tau_1 \rightarrow \tau_2} = \arrow{\sem{\tau_1}}{\mon(\sem{\tau_2})} \\
  &\sem{\Gamma \turnv \abs{x}{\tau_1}{c} \types \tau_1 \rightarrow \tau_2} =
    \currymap(\sem{\lbind{\Gamma}{x}{\tau_1} \turnc c \types \tau_2})
     \\
  &\sem{\Gamma \turnc \app{v_1}{v_2} \types \tau_2} =
    \evmap
    \circ \langle \sem{\Gamma \turnv v_1 \types \tau_1 \rightarrow \tau_2},
                  \sem{\Gamma \turnv v_2 \types \tau_1} \rangle
\end{align*}
where $\evmap$ is the evaluation map and $\currymap$ the currying of
exponentials.

\subsection{The global modality}

For any category $\cat$, if $\cat$ has a terminal object $\terminal$, we
can define the global modality $\glob \types [\psh, \psh]$ such that:
$\glob(P)(L) = P(\terminal)$. In the case of $\pshlawcop$ this becomes:
\begin{equation*}
\glob(P)(L) = P(\initial)
\end{equation*}
$\glob$ forms a comonad on $\pshlawcop$. $\glob$ also distributes over
products: $\glob (P \times Q) = (\glob P) \times (\glob Q)$

Within our semantics, this amounts to restricting a type to only the
elements which do not depend on the ambient monad. This is very similar
to the purity comonad of Choudhury and
Krishnaswami\cite{choudhury2020recovering}. In particular,
\begin{equation*}
  \glob \mon(P) \quad = \quad T_{\initial} \circ \glob P
  \quad \cong \quad \glob P
\end{equation*}
as elements of the free algebras of the initial algebraic theory are
just elements of their carrier sets.

We use the $\glob$ comonad as our semantics for $\glob$ types and
$\glob$ bindings.
\begin{align*}
&\sem{\glob \tau} = \glob \sem{\tau} \\
&\sem{\gbind{\Gamma}{x}{\tau}} = \sem{\Gamma} \times \glob \sem{\tau} \\
&\sem{\gbind{\Gamma}{x}{\tau} \turnv x \types \tau} = \epsilon \circ \snd \\
&\sem{\Gamma \turnv \gbox{v} \types \glob \tau} =
  \glob \sem{\cdiv{\Gamma} \turnv v \types \tau}
  \circ \eta \circ \cdiv{\Gamma} \\
&\sem{\Gamma \turnv \gunbox{x}{v_1}{v_2} \types \tau_2} =
  \sem{\gbind{\Gamma}{x}{\tau_1} \turnv v_2 \types \tau_2}
  \circ \langle id_{\sem{\Gamma}},
                \sem{\Gamma \turnv v_1 \types \glob \tau_1} \rangle \\
&\sem{\Gamma \turnv \grun{c} \types \glob \tau} =
  \rho_{\sem{\tau}}
  \circ \glob \sem{\cdiv{\Gamma} \turnc c \types \tau}
  \circ \eta \circ \cdiv{\Gamma}\\
\end{align*}
where $\epsilon$ and $\eta$ are the counit and comultiplication of
$\glob$, $\cdiv{\Gamma} \types \Gamma \rightarrow \cdiv{\Gamma}$ is the
morphism that projects the global bindings from $\Gamma$, and $\rho_P$
is the isomorphism from $\glob \mon(P)$ to $\glob P$.

\subsection{Reflecting operations: The Yoneda embedding}

We want to be able to reflect operations into the ambient monad. We can
use the $op_{T_L}$ functions to build morphisms into $\mon$, but we
require some way to represent operations of the ambient monad. We can do
that by using the \emph{Yoneda embedding}. The Yoneda embedding
$\yoneda{\_}$ is a full and faithful embedding from a category $\cat$
into its category of presheaves $\psh$. When treating $\cat$ as a form
of context, the elements of $y(\catobj)$ can be used to represent
variables of type $\catobj$.

$\lawcop$ embeds into $\pshlawcop$ via the Yoneda embedding: for each
Lawvere theory $L$ there is a presheaf $\yoneda{L}$ in $\pshlawcop$ such
that:
\begin{align*}
&\yoneda{L}(L^{\prime}) = \homset{\lawc}{L}{L^{\prime}} \\
&\yoneda{L}(l^{\prime}) = \lambda f.\; l^{\prime} \circ f
\end{align*}

For an operation $op \types P \rightarrowtail A$ of a Lawvere theory $L$
and some set $S$, we can build a morphism:
\begin{align*}
&op_{\mon{S}} \types
  \homset{\pshlawcop}
         {\yoneda{L} \times \glob P \times \arrow{\glob A}{\mon{S}}}
         {\mon{S}} \\
&{(op_{\mon{S}})}_{L^\prime}
  = \lambda(y, p, k). (y(op))_{T_{L^\prime}}(p, \lambda a. k_{L^\prime}(id_{L^\prime}, a))
\end{align*}
which uses an element of $\yoneda{L}$ to map $op$ into the ambient monad
and then uses that to construct a term in the free algebras monad.

We use $\yoneda{L}$ as the semantics for our handler types, and
$op_{\mon{S}}$ as the semantics for reflection.
\begin{align*}
&\sem{\yoneda{\Sigma}} = \yoneda{\sem{\Sigma}} \\
&\sem{\Gamma \turnc \perform{v_1}{op}{v_2}{x}{c} \types \tau} = \\
&\quad op_{\mon{\sem{\tau}}}
       \circ \langle \sem{\Gamma \turnv v_1 \types \yoneda{\Sigma}},
                      \sem{\Gamma \turnv v_2 \types \tau_p},
                      \currymap(\sem{\lbind{\Gamma}{x}{\tau_a} \turnc c \types \tau})
             \rangle
\end{align*}
where $\sem{\Sigma}$ is the Lawvere theory corresponding to the
signature $\Sigma$. If $\Sigma$ is:
\begin{equation*}
  \{ \, op_1 \types \tau_{p_1} \rightarrowtail \tau_{a_1} \seq
  \ldots \seq
  op_n \types \tau_{p_n} \rightarrowtail \tau_{a_n} \, \}
\end{equation*}
then $\sem{\Sigma}$ is the Lawvere theory for:
\begin{equation*}
  \{ \, op_1 \types \sem{\tau_{p_1}}(\initial)
                    \rightarrowtail \sem{\tau_{a_1}}(\initial) \seq
  \ldots \seq
  op_n \types \sem{\tau_{p_n}}(\initial)
              \rightarrowtail \sem{\tau_{a_n}}(\initial) \, \}
\end{equation*}
Note that by applying the types to the initial theory $\initial$ we
restrict them to their global elements: those that do not depend on the
current ambient monad.

The Yoneda embedding preserves finite products, which for our case
means:
\begin{equation*}
\yoneda{L + L^{\prime}} \cong \yoneda{L} \times \yoneda{L^{\prime}}
\end{equation*}
which we use for the semantics of $\outlname$ and $\outrname$.

\subsection{Representing effectful computations: The Yoneda lemma}

We can represent computations in a specific algebraic monad using the
Yoneda lemma. The Yoneda lemma says that, for any $P \types \psh$ and
$\catobj \types \cat$, there is an isomorphism:
\begin{equation*}
  \homset{\psh}{\yoneda{\catobj}}{P} \cong P(\catobj)
\end{equation*}

Applying that to the composition of the free algebras monad and the
global modality we get:
\begin{equation*}
  \homset{\pshlawcop}{\yoneda{L}}{\mon{\glob \tau}} \cong \mon{\glob \tau}(L) = T_L(\tau(\initial))
\end{equation*}

In terms of our semantics, this means that computations of type
$\glob \tau$ with a single variable of type $\yoneda{\Sigma}$ are
isomorphic to values of the free algebra of $\sem{\Sigma}$ at
$\sem{\tau}(\initial)$.

\subsection{Effect reification and inductive types}

The essence of algebraic effect handlers is taking a computation in
$T_{L + \Sigma}(S)$ the free algebras of the sum of an algebraic theory
$L$ and an algebraic signature $\Sigma$, splitting out and handling
$\Sigma$, leaving a computation in only the algebraic theory
$T_{L}(S^\prime)$.

The key to this process is the following lemma
\cite{hyland2006combining}.
\begin{lemma}
\label{lemma:sums}
  For any Lawvere theory $L$ and algebraic signature $\Sigma$
  \begin{equation*}
  T_{L + \Sigma}(S) \cong \mu X.T_L(S + F_\Sigma(X))
  \end{equation*}
\end{lemma}
where $\mu X.G(X)$ is the initial algebra of some polynomial endofunctor
$G$, and $F_\Sigma$ is the endofunctor on $\setc$ for which $T_{\Sigma}$
is the free monad.

Effect reification works by exposing $\mu X.T_L(S + F_\Sigma(X))$ to the
user via an inductive type. Categories of presheaves have initial
algebras of polynomial endofunctors, i.e. W-types, so we can construct
the required initial algebra as a presheaf. Given an algebraic
signature $\Sigma$ and a presheaf $P$, we define the following family
of initial algebras:
\begin{align*}
&\ind{\Sigma} \types [\pshlawcop, \pshlawcop] \\
&\ind{\Sigma}(P) = \mu X. (P + F_\Sigma \circ \mon{X})
\end{align*}
and observe the following variation on Lemma \ref{lemma:sums}.
\begin{lemma}
\label{lemma:sums2}
  For any Lawvere theory $L$ and algebraic signature $\Sigma$
  \begin{equation*}
  T_{L + \Sigma}(P(L)) \cong \mon{(\ind{\Sigma}(P))}(L)
  \end{equation*}
\end{lemma}

We use these initial algebras as the denotational semantics of
$\ind{\Sigma}$:
\begin{mathpar}
\sem{\ind{\Sigma}(\tau)} = \ind{\sem{\Sigma}}(\sem{\tau})
\end{mathpar}

Exponentials in categories of presheaves are defined such that:
\begin{equation*}
\arrow{P}{Q}(\catobj) \cong \homset{\psh}{\yoneda{\catobj} \times P}{Q}
\end{equation*}
Applying this to $\arrow{\yoneda{L}}{\mon{(\glob P)}}$ and then applying
the Yoneda Lemma we get:
\begin{align*}
\arrow{\yoneda{L}}{\mon{(\glob P)}}(L^{\prime})
  &\cong \homset{\pshlawcop}{\yoneda{L^{\prime}} \times \yoneda{L}}{\mon{(\glob P)}} \\
  &\cong \homset{\pshlawcop}{\yoneda{L^{\prime} + L}}{\mon{(\glob P)}} \\
  &\cong \mon{(\glob P)}(L^{\prime} + L) \\
  &\cong T_{(L^{\prime} + L)}(P(L^{\prime}))
\end{align*}

In the case where $L$ is a signature $\Sigma$, we can further apply
Lemma \ref{lemma:sums2} and, observing that all the steps in this proof
were natural in $L^{\prime}$, produce this isomorphism:
\begin{equation*}
  \arrow{\yoneda{\Sigma}}{\mon{(\glob P)}} \cong \mon{(\ind{\Sigma}(\glob P))}
\end{equation*}
which we call $\reifyc{\Sigma}{}$.

$\reifyc{\Sigma}{}$ gives us our semantics for reification.
\begin{align*}
&\sem{\Gamma \turnc \reify{\Sigma}{x}{c} \types \ind{\Sigma}(\glob \tau)} =
  \reifyc{\Sigma}{\tau} \circ \currymap(\sem{\lbind{\Gamma}{x}{\yoneda{\Sigma}} \turnc c \types \glob \tau}) \\
\end{align*}

\section{Implementation}
\label{sec:implementation}

\subsection{Implementation with untracked effect handlers}

We can implement the interface from Section \ref{sec:interface} directly
in terms of OCaml's untracked effect
handlers\cite{Sivaramakrishnan2021retrofitting}. The trick is to
generate a fresh effect constructor for each reification, pass that
constructor around as part of the \lstinline[style=oxcaml]{handler}, and
then use it to perform operations during reflection. The full implementation
is given in Fig.\ref{fig:implementation}.
\begin{figure}
\begin{lstlisting}[style=oxcaml]
module Handler (O : Op) = struct

  type t = { perform : 'r. 'r O.t -> 'r }

end

module Reflection (O : Op) = struct

  let reify f =
    let module Handler =
      struct type 'a Effect.t += H : 'a O.t -> 'a Effect.t end
    in
    let handler : Handler(O).t =
      { perform = fun o -> Effect.perform (Handler.H o) }
    in
    match f handler with
    | v -> Return v
    | effect Handler.H o, k -> Op(o, fun x -> Effect.continue k x)

  let reify_local f = exclave
    let module Handler =
      struct type 'a Effect.t += H : 'a O.t -> 'a Effect.t end
    in
    let handler = { perform = fun o -> Effect.perform (Handler.H o) } in
    match f handler with
    | v -> Return v
    | effect Handler.H o, k -> Op(o, fun x -> Effect.continue k x)

  let perform t =
   fun h -> h.perform t

end

module Project (L : Op) (R : Op) = struct

  let outl {perform} =
    {perform = fun op -> perform (Sum(L)(R).Left op)}

  let outr {perform} =
    {perform = fun op -> perform (Sum(L)(R).Right op)}

end
\end{lstlisting}
\caption{Implementation}
\label{fig:implementation}
\end{figure}

\subsection{More efficient implementation in terms of fibers}

In the implementation in Fig.\ref{fig:implementation}, whenever an
operation is reflected we perform a linear search up the stack of
handlers until we find the corresponding one. This search is not
actually necessary: there is a one-to-one relationship between the
handlers and the handler values used to reflect operations. By modifying
the OxCaml runtime to allow values on the locals stack that directly
point to the fibers used to implement effect handlers we can reflect
operations by jumping directly to the relevant handler. This is roughly
the implementation technique described by Ma et al.\cite{ma2024lexical}.

\section{Related work}
\label{sec:related-work}

\subsection{Lexical and named effect handlers}

Effect reflection is closely related to \emph{lexical effect handlers}
in systems such as Effekt\cite{brachthauser2020effects} or Biernacki et
al. \cite{biernacki2019binders}. Lexical effect handlers have a value
that represents the effect handler, similar to $\yoneda{\Sigma}$ values,
but these values are second class and require their own special typing
rules. More recent work on Effekt\cite{brachthauser2022effects}
addresses the second-class nature of these values, but requires further
extending the type system by tracking the set of capabilities used by
each value.

Effect reflection is also closely related to \emph{named effect
  handlers}\cite{xie2022first}. Named effect handlers use higher-rank
polymorphism to emulate locality tracking in much the same way as the
\lstinline[style=haskell]{St} monad in Haskell. This still requires
using an effect system to track which named effects are used by a
computation, in order to ensure that those effects do not escape the
scope of their handler. Using higher-rank polymorphism also prevents
global type inference, requiring complex inference that extends beyond
classic Hindley-Milner, and demanding a higher annotation burden on the
programmer.

\subsection{Monadic reflection}

Effect reflection is a variation on monadic
reflection\cite{filinski1999representing}. By restricting ourselves to
algebraic monads with no equations we remove the need to manually define
\emph{glue} that describes the interaction between the monad being
reified and the current ambient monad. By using locality and
$\yoneda{\Sigma}$ values we avoid the need to have an effect system.

\subsection{Semantics of algebraic effect handlers}

Hyland et al.\cite{hyland2006combining} investigate combining algebraic
effects, including the key property of sums of algebraic theories (our
Lemma \ref{lemma:sums}) on which handlers are based.

The original work on algebraic effect
handlers\cite{plotkin2009handlers,plotkin2013handling} gives a semantics
in terms of free algebras but the semantics work with a fixed algebraic
theory: handlers do not actually change the ambient monad.

\subsection{Comonadic purity}

Our use of a comonadic global modality to track values which do not
depend on the ambient monad is essentially the same as the purity
comonad described by Choudhury and
Krishnaswami\cite{choudhury2020recovering}. Their semantic description
of their comonad is very different -- based on a semantics of
capabilities -- but the typing rules, and the practical result, are the
same.

\subsection{Locality and presheaves}

Our presheaf semantics are closely related to presheaf semantics for
higher-order abstract syntax\cite{hu2022category}. In both cases
presheaves are used to index the semantics of types and terms by some
notion of context, with the Yoneda embedding used to access this context
and the global modality used to control it.

\bibliography{references}
\bibliographystyle{plain}

\end{document}
