\documentclass[acmsmall, screen, nonacm]{acmart}

\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{fontawesome5}
\usepackage{mathpartir}
\usepackage{sourcecodepro}

\lstset{
  basicstyle=\ttfamily\small,
  columns=fullflexible,
  keepspaces=true
}

\lstdefinestyle{ocaml}{
  keywordstyle=\color{blue},
  emphstyle=\color{violet},
  language=[Objective]Caml,
  morekeywords={effect, exclave},
  escapeinside={(*@}{@*)},
  literate=
    {[]}{$\glob$}{1}
}

\lstdefinestyle{haskell}{
  keywordstyle=\color{blue},
  emphstyle=\color{violet},
  language=Haskell
}

\newcommand{\glob}{\mathop{\Box}}
\newcommand{\cat}{\mathbb{C}}
\newcommand{\catop}{\cat^{\mathtt{op}}}
\newcommand{\id}[1]{\mathrm{id}_{#1}}
\newcommand{\setc}{\mathrm{Set}}
\newcommand{\psh}{\widehat{\cat}}
\newcommand{\terminal}{\top}
\newcommand{\initial}{\bot}
\newcommand{\lawc}{\mathrm{Law}}
\newcommand{\lawcop}{\lawc^{\mathtt{op}}}
\newcommand{\pshlawcop}{\widehat{\lawcop}}
\newcommand{\freef}{Free}
\newcommand{\constfname}{\Omega}
\newcommand{\constf}[1]{\constfname #1}
\newcommand{\yonedaname}{y}
\newcommand{\yoneda}[1]{y(#1)}
\newcommand{\homset}[3]{\mathrm{Hom}_{#1}(#2, #3)}
\newcommand{\arrow}[2]{#1 \Rightarrow #2}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\reflectname}{\Uparrow}
\newcommand{\reflect}[2]{\reflectname_{#1}(#2)}
\newcommand{\reifyname}{\Downarrow}
\newcommand{\reify}[2]{\reifyname_{#1}(#2)}
\newcommand{\lock}{\text{\faLock}}
\newcommand{\mon}{\mathcal{T}}
\newcommand{\ind}[1]{W_{#1}}

\newcommand{\todo}[1]{{\color{red}TODO: #1}}

\title{Locality and Effect Reflection}
\author{Leo White}
\affiliation{\institution{Jane Street}\country{UK}}
\date{}
\setcopyright{none}

\begin{document}

\begin{abstract}
  Algebraic effects and handlers allow the programmer to extend their
  languages \emph{ambient monad} \textbf{--} the monad describing which
  effects ordinary functions can perform \textbf{--} with additional
  effectful operations.

  Locality captures the general idea of a value depending on some notion
  of ``location''. We can represent it in a type system using a
  comonadic \emph{global modality} $\glob$ that tracks which values do
  not depend on their location. A particularly useful notion of
  ``location'' is the ambient monad.

  We introduce an alternative presentation of algebraic effects and
  handlers, \emph{effect reflection}, that provides, for any algebraic
  theory $\Sigma$, an isomorphism:
  \begin{equation*}
    \ind{\Sigma}(\glob \tau) \qquad \cong \qquad \yoneda{\Sigma} \rightarrow \glob \tau
  \end{equation*}
  where $\ind{\Sigma}$ is an inductive type representing the free
  algebra of $\Sigma$, and $\yoneda{\Sigma}$ is a type representing how
  to inject terms of $\Sigma$ into the current ambient
  monad. $\ind{\Sigma}$ is sometimes called the \emph{freer monad} of
  $\Sigma$. This presentation falls out naturally from a simple
  denotational semantics for algebraic effects in terms of presheaves
  over bounded Lawvere theories.

  Effect reflection lets you work with any algebraic monad using an
  ordinary function type, allowing monadic code to be written in direct
  style. This provides all the benefits of typed algebraic effects and
  handlers without requiring an effect system. We demonstrate effect
  reflection by implementing it as a library in
  OxCaml\cite{lorenzen2024oxidizing,} and working through some classic
  examples of programming with effects.
\end{abstract}

\maketitle

\section{Reflection for algebraic effects}

\paragraph{Algebraic effects} Algebraic effects and handlers are an
increasingly popular approach to programming with effects. Handlers
allow the programmer to add additional effects to the \emph{ambient
  monad} of their language -- the monad describing which effects an
ordinary function can perform -- for some region of their program.

For example, in OCaml, one can write:
\begin{lstlisting}[style=ocaml]
type 'a Effect.t +=
  | Get : int Effect.t
  | Set : int -> unit Effect.t

let handle (f : unit -> 'a) : 'a =
  match f () with
  | x -> fun _ -> x
  | effect Get, k -> fun s -> continue k s s
  | effect Set s', k -> fun _ -> continue k () s'
\end{lstlisting}
and for the duration of the \lstinline[style=ocaml]{f ()} function call
the ambient monad is extended with two additional effectful operations:
\begin{lstlisting}[style=ocaml]
let get () : int = perform Get
let set (i : int) : unit = perform (Set i)
\end{lstlisting}

Note that, in OCaml, nothing prevents attempting to perform an algebraic
effect operation that is not supported by the current ambient monad,
resulting in an \lstinline[style=ocaml]{Unhandled} exception being
raised. Other languages, e.g. Koka\cite{??}, use an effect system to
statically ensure operations are only performed when they are available.

\paragraph{Locality and effect reflection} Locality captures the general idea of a value
depending on some notion of ``location''. We can represent it in a type
system using a comonadic \emph{global modality} $\glob$ that tracks
which values do not depend on their location. A particularly useful
notion of ``location'' is the ambient monad.

Treating the ambient monad as a notion of location allows a language to
provide an isomorphism:
\begin{equation*}
  \mathop{M}(\glob X) \qquad \cong \qquad Y \mathbin{\rightarrow} \glob X
\end{equation*}
where $M$ is any algebraic monad, $Y$ is a specific type related to that
monad, and $\glob$ is a comonadic global modality. We call this
isomorphism \emph{effect reflection}.

The ability to use the ordinary arrow type
$Y \mathbin{\rightarrow} \glob X$ in place of the monad
$\mathop{M}(\glob X)$ allows us to conveniently write effectful
code in direct style, just as algebraic effects do.

\paragraph{Effect reflection in OxCaml}
OxCaml\cite{lorenzen2024oxidizing} provides type system support for
tracking locality and runtime support for algebraic effects. For
backwards compatibility with OCaml, an unadorned arrow type
\lstinline[style=ocaml]{t -> s} is treated as if the parameter and
return types were actually \lstinline[style=ocaml]{[]t} and
\lstinline[style=ocaml]{[]s}. To get parameters or results that are not
implicitly global, we write
e.g. \lstinline[style=ocaml]{t @ local -> s @ local}.

Using this support, with can provide effect reflection as a simple API
that we can use for programming with effects.  For example, we can use
it to write an effect handler equivalent to the OCaml one above:
\begin{lstlisting}[style=ocaml]
module State = struct
  type 'a t =
    | Get : int t
    | Set : int -> unit t
end

module State_eff = Reflection(State)

let handle (f : Handler(State).t @ local -> 'a) : 'a =
  let rec loop s : 'a Term(State).t -> 'a  = function
    | Return x -> x
    | Op(Get, k) -> loop s (k s)
    | Op(Set s', k) -> loop s' (k ())
  in
  loop (State_eff.reify f)
\end{lstlisting}
which calls \lstinline[style=ocaml]{f} and passes it a local value of
type \lstinline[style=ocaml]{Handler(State).t}. For the duration of the
call to \lstinline[style=ocaml]{f} the ambient monad is extended with
two additional effectful operations, which can be used via reflection:
\begin{lstlisting}[style=ocaml]
let get (h : Handler(State).t @ local) : int =
  State_eff.reflect (Op(Get, fun x -> x)) h

let set (h : Handler(State).t @ local) (i : int) : unit =
  State_eff.reflect (Op(Set i, fun x -> x)) h
\end{lstlisting}

Note that the locality of the handler value ensures that these
operations can only be performed when they are available in the ambient
monad. This provides the same guarantees as using an effect system.

Effect reflection is closely related to \emph{lexical effect handlers} in
systems such as Effeckt\cite{??}. Lexical effect handlers have a value that
represents the effect handler, but these values are second class and
require their own special typing rules.

Effect reflection is also closely related to \emph{named effect
  handlers}\cite{??}. Named effect handlers use higher-rank polymorphism
to emulate locality tracking in much the same way as the
\lstinline[style=haskell]{St} monad in Haskell. Using higher-rank
polymorphism prevents global type inference, requiring complex inference
that extends beyond classic Hindly-Milner, and demanding a higher
annotation burden on the programmer. \todo{Mention the explicit monad
that named effect handlers presumably need.}

Effect reflection is a variation on monadic reflection\cite{??}.
\todo{Make this relationship precise.}

\paragraph{Denotational semantics} The design of effect reflection falls
out naturally from a simple denotational semantics of algebraic
effects. The underlying idea is to index the semantics by the ambient
monad. Rather than the semantics of a type being a set it is instead a
function from ambient monads to set: if you tell it what the ambient
monad is it can tell you what its set of values is.

The semantics is defined in terms of presheaves of the opposite of the
category of \emph{bounded Lawvere theories}. Bounded Lawvere theories
are a categorical representation of algebraic theories: we represent the
ambient algebraic monad by the corresponding algebraic theory. The key
constructs of effect reflection are then defined as follows:

\begin{itemize}
\item The global modality $\glob$ on such presheaves is defined such
  that $\glob(P)(L) = P(\initial)$. In other words, for a given presheaf
  $P$ it gives the constant presheaf that always ignores the ambient
  monad and instead returns $P$ at $\initial$, where $\initial$ is the
  algebraic theory with no operations or equations. This basically
  restricts a type to its terms that do not depend on the ambient monad.

\item The ambient monad can be defined as a monad $\mon$ on such
  presheaves, which maps each algebraic theory to its free algebra. We use
  $\mon$ to define the semantics of computations.

\item The semantics of our handler types $Y$ are given by the Yoneda
  embedding, and our effect reflection isomorphism becomes a simple
  consequence of the Yoneda lemma.
\end{itemize}

These presheaf semantics are closely related to presheaf semantics for
higher-order abstract syntax\cite{??}.

\paragraph{Structure of the paper} We proceed as follows:
\begin{itemize}
\item In Section \ref{sec:pracice}, we give an overview of effect reflection in
  practice in OxCaml
\item In Section \ref{sec:semantics}, we describe the constructions for a
  novel denotational semantics of algebraic effects
\item In Section \ref{sec:language}, we define a simply typed calculus featuring
  effect reflection along with its denotational semantics
\item In Section \ref{sec:implementation}, we give an implementation of effect
  reflection in OxCaml in terms of the untracked algebraic effects it
  inherits from OCaml.
\item In Section \ref{sec:related-work}, we discuss related work, and in
  Section \ref{sec:future-work}, we discuss future work.
\end{itemize}

\section{Effect reflection in practice}
\label{sec:pracice}

We can provide effect reflection as a simple library API in OxCaml. In
this section we describe this API and show how to use it to write a
number of typical examples of algebraic effects.

\subsection{Locality in OxCaml}

The effect reflection API relies on OxCaml's support for tracking
locality in types, so let's start with an overview of that support.

Values in OxCaml are associated with both a type -- which describe how
values can be introduced and eliminated -- and a \emph{mode} -- which
track properties related to operations other than introduction and
elimination. Modes are a product of a number of different axes, tracking
a variety of different properties, but here we are only interested in
one of them: \emph{locality}. Ignoring the other axes, a mode is either
\lstinline[style=ocaml]{local} or \lstinline[style=ocaml]{global}.

Locality tracks the ability of a value to leave \emph{regions}.  Regions
describe some period of time during a program's execution. Every
function call defines a corresponding region that, by default, lasts for
the entire extent of the call. This means that, by default,
\lstinline[style=ocaml]{local} values cannot be returned from a
function.
\begin{lstlisting}[style=ocaml]
let leak_local x =
  let (o @ local) = Some x in
  o
(*@ \textcolor{red}{Error: This value is local and would escape its region.} @*)
\end{lstlisting}

To support functions that return local values, the region of a function
can be ended early using the \lstinline[style=ocaml]{exclave} construct.
\begin{lstlisting}[style=ocaml]
let return_local x =
  exclave
    (let (o @ local) = Some x in
     o)
\end{lstlisting}
\lstinline[style=ocaml]{exclave e} can only appear in tail position
within a function.  It ends the function's region early and then
executes the expression
\lstinline[style=ocaml]{e}. \lstinline[style=ocaml]{e} is essentially
executed within the region of the caller of the function and any local
values created within it can be safely returned to that caller.

The place where modes appear within the type algebra is on arrow
types. A function being \lstinline[style=ocaml]{global} doesn't tell you
that the values it accepts or returns should be
\lstinline[style=ocaml]{global} too, so instead the arrow type is
labelled with two modes: one for the argument and one for the return
value.
\begin{lstlisting}[style=ocaml]
val return_local : 'a @ local -> 'a option @ local
\end{lstlisting}
For convenience, and backwards compatibility with OCaml, either mode can
be omitted, in which case it defaults to
\lstinline[style=ocaml]{global}.

By default, modes are deep: a local \lstinline[style=ocaml]{string list}
is a local list of local strings. However, the depth that a mode applies
can be controlled via \emph{modalities}. Record fields can be annotated
with \lstinline[style=ocaml]{global} modality to indicate that the
contents of the field are global even when the surrounding record is
local. For example:
\begin{lstlisting}[style=ocaml]
type 'a gbl = { g : 'a @@ global }
\end{lstlisting}
gives a record whose only field has the \lstinline[style=ocaml]{global}
modality. The contents of the \lstinline[style=ocaml]{g} field is always
global, for example:
\begin{lstlisting}[style=ocaml]
let return_global x =
  let (r @ local) = { g = x } in
  r.g
\end{lstlisting}
is allowed and gives a function of type:
\begin{lstlisting}[style=ocaml]
val return_global : 'a @@ global -> 'a @@ global
\end{lstlisting}
Variant constructor arguments can also be annotated with modalities.

Note that, whilst there is a \lstinline[style=ocaml]{global} modality,
there is no \lstinline[style=ocaml]{local} modality. It does not make
sense for a value which has the ability to leave a region to contain a
value which doesn't, as when the first value leaves a region is will
implicit cause the second one to leave that region as well. This means
the \lstinline[style=ocaml]{global} mode is always deep.

\subsection{Effect reflection interface}
\label{sec:interface}

\begin{lstlisting}[style=ocaml]
module type Op = sig type 'a t end

module Term (O : Op) : sig
  type 'a t =
    | Return : 'a @@ global -> 'a t
    | Op : 'r O.t @@ global * ('r -> 'a t) -> 'a t
end

module Handler(O : Op) : sig
  type 'a t
end

module Reflection (O : Op) : sig

  val reify : (Handler(O).t @ local -> 'a) -> 'a Term(O).t

  val reflect : 'a Term(Op).t -> (Handler(O).t @ local -> 'a)

  val reify_local : (Handler(O).t @ local -> 'a) @ local -> 'a Term(O).t @ local

  val reflect_local : 'a Term(O).t @ local -> (Handler(O).t @ local -> 'a) @ local

end
\end{lstlisting}

\begin{lstlisting}[style=ocaml]
let perform (op : 'a O.t) : 'a =
  reflect (Op(op, fun x -> x))
\end{lstlisting}

\subsection{One-shot continuations}

For various practical reasons, OCaml's algebraic effects are restricted
to only allow continuations to be resumed a single time. This rules out
interesting effects like backtracking search, but improves the ability
to reason about the interaction of effects and resources.

There is no fundamental reason that effect reflection should be
restricted to only one-shot continuations, so for the purposes of this
paper we shall ignore the restriction. However, for the same reasons as
OCaml, our actual implementation is restricted one-shot
continuations. Note that OxCaml's \lstinline[style=ocaml]{once}
mode\cite{lorenzen2024oxidizing} allows us to enforce this restriction
statically.

\subsection{Effect sums}

\begin{lstlisting}[style=ocaml]
module Sum (L : Op) (R : Op) : sig
  type 'a t =
    | Left : 'a L.t -> 'a t
    | Right : 'a R.t -> 'a t
end

module Project(L : Op) (R : Op) : sig
  val outl : Handler(Sum(L)(R)).t -> Handler(L).t

  val outr : Handler(Sum(L)(R)).t -> Handler(R).t
end
\end{lstlisting}

As a Lawvere theory, \lstinline[style=ocaml]{Sum(L)(R)} is the sum of
\lstinline[style=ocaml]{L} and \lstinline[style=ocaml]{R}. This means
that the terms of its free algebra $T_{L + R}(\tau)$ are equivalent to
values of the initial algebra $\mu X. T_L(\tau + F_L(X)$. We can expose
this fact via the following functions:
\begin{lstlisting}
module Half_term (L : Op) (R : Op) : sig
  type 'a t =
    | Return : 'a @@ global -> 'a t
    | Op : 'r R.t @@ global * ('r -> Handler(L).t @ local -> 'a t) -> 'a t

  let rec reflect_left : 'a Term(Sum(L)(R)).t -> (Handler(L).t @ local -> 'a Half_term(L)(R).t)
   = function
    | Return v -> fun _ -> Return v
    | Op(Left op, k) -> fun l -> L.reflect (Op(op, (fun res -> reflect_left (k res) l)))
    | Op(Right op, k) -> fun _ -> Op(op, (fun res -> reflect_left (k res)))

  let rec reify_left : (Handler(L).t @ local -> 'a Half_term(L)(R).t) -> 'a Term(Sum(L)(R)).t =
    fun h ->
      let rec loop = function
        | Return (Return x) -> Return x
        | Return (Op(r, k)) -> Op(Right r, fun res -> reify_left (k res))
        | Op(l, k) -> Op(Left l, fun res -> loop (k res))
      in
      loop (L.reify h)

end
\end{lstlisting}

\subsection{Examples}

\subsubsection{State}

\subsubsection{Concurrency}

\subsubsection{Generators and concurrency}

\section{Presheaves for algebraic effects}
\label{sec:semantics}

Our language falls out naturally from its categorical semantics, so we
focus on that. We intend to index the meaning of types by an ambient
algebraic monad of effects: rather than have the semantics of each type
be a set of elements, the semantics of each type is a mapping from the
ambient monad to a set of elements.

For a category $\cat$, $\psh = \setc^{\catop}$ is the category of
presheaves over $\cat$. If $\cat$ has a terminal object $\terminal$, we
can define the global modality $\glob \mathrel{:} [\psh, \psh]$ such that:
\begin{equation*}
  \glob(P)(L) = P(\terminal)
\end{equation*}

We use the ambient monad as our notion of location, so we take $\cat$ to
be $\lawcop$, where $\lawc$ is the category of countable Lawvere
theories. Lawvere theories are a categorical representation of algebraic
theories. Morphisms in $\lawc$ are maps from the operations of one
theory to the operations of another that preserve the equations of the
first theory according to the equations of the second.  The initial
theory is the algebraic theory with no operations. The coproduct of two
theories is the theory made by combining the operations and equations of
both theories.

Given a Lawvere theory $L$, the underlying set of its free algebra forms
a monad $T_L$ on $\setc$. $T_{\_}$ is functorial and we can use it to
construct a monad $\mon$ on $\pshlawcop$ in the obvious way, such that:
\begin{equation*}
\mon(P)(L) = T_L(P(L))
\end{equation*}
We will use $\mon$ as our computation monad.

$\lawcop$ embeds into $\pshlawcop$ via the Yoneda embedding. For each
Lawvere theory $L$ there is a presheaf $\yoneda{L}$ in $\pshlawcop$ such
that:
\begin{equation*}
\yoneda{L}(L^{\prime}) = \homset{\lawc}{L}{L^{\prime}}
\end{equation*}
We will use $\yoneda{L}$ to represent maps from $L$ into the ambient
monad. Note that $\yonedaname$ preserves finite products:
$\yoneda{L + L^{\prime}} \cong \yoneda{L} \times \yoneda{L^{\prime}}$
where $+$ is the coproduct in $\lawc$, which is the product in
$\lawcop$.

Categories of presheaves are cartesian closed, and the exponential
$\arrow{P}{Q}$ in $\pshlawcop$ maps $L$ to
$\homset{\pshlawcop}{\yoneda{L} \times P}{Q}$. So, via the Yoneda lemma,
we get the following:
\begin{align*}
(\arrow{\yoneda{L}}{\mon(\glob A)})(L') \quad \cong \quad &T_{(L' + L)}(A(\terminal))
\end{align*}
which will form the basis of our language's isomorphisms between arrows
$Y \rightarrow \glob A$ and algebraic monads $M(\glob A)$.

\section{A language with effect reflection}
\label{sec:language}

We build a simple language to (mostly) achieve our aim. Rather than
working with arbitrary algebraic monads as promised, we follow the
finest traditions of the algebraic effects literature and restrict our
attention to algebraic theories without equations. Our language is
simply typed, featuring all the usual type-formers. It uses a variation
of fine-grained call-by-value: it has separate syntax and typing
judgements for values and computations.

We define algebraic signatures $\Sigma$ as finite sets of operations
\[
\{ op_1 \mathop{:} \tau_{p_1} \rightarrowtail \tau_{a_1}; \ldots; op_n
\mathop{:} \tau_{p_n} \rightarrowtail \tau_{a_n} \}
\]
An operation type
$\tau_p \rightarrowtail \tau_a$ indicates an operation parameterised by
$\tau_p$ and with arity $\tau_a$. Such signatures correspond to Lawvere
theories without equations. We restrict parameters and arities to base
types to ensure that our theories only have a countable number of
operations of countable arities. We write $\sem{\Sigma}$ for the
corresponding Lawvere theory, and $F_\Sigma$ for the endofunctor on
$\setc$ for which $T_{\sem{\Sigma}}$ is the free monad.

The language provides inductive types $\ind{\Sigma}$ to directly
represent terms of an algebraic signature $\Sigma$. $\ind{\Sigma}(\tau)$
has a constructor $op$ with arguments of type $\tau_p$ and
$\tau_a \rightarrow \ind{\Sigma}(\tau)$ for each operation
$op \mathop{:} \tau_p \rightarrowtail \tau_a$ in $\Sigma$, as well as a
constructor $ret$ with an argument of type $\tau$.

The language provides types $\yoneda{\Sigma}$ to represent morphisms
from $\sem{\Sigma}$ into the ambient monad. Using these, our desired
isomorphism appears in the language as two operations, reflection
$\reflect{\Sigma}{c}$ and reification $\reify{\Sigma}{v}$.
\begin{mathpar}
\inferrule{\Gamma \mathrel{\vdash_C} c : \ind{\Sigma}(\glob \tau)}
{\Gamma \mathrel{\vdash_V} \; \reflect{\Sigma}{c} : \yoneda{\Sigma} \rightarrow \glob \tau}
\and
\inferrule{\Gamma \mathrel{\vdash_V} v : \yoneda{\Sigma} \rightarrow \glob \tau}
{\Gamma \mathrel{\vdash_C} \; \reify{\Sigma}{v} : \ind{\Sigma}(\glob \tau)}
\end{mathpar}

Our denotational semantics in terms of $\pshlawcop$ is
straightforward. For types, the translation $\sem{\tau} \mathrel{:} \pshlawcop$ is as follows:
\begin{mathpar}
\sem{\yoneda{\Sigma}} = \yoneda{\sem{\Sigma}} \and
\sem{\glob \tau} = \glob \sem{\tau} \and
\sem{\tau_1 \rightarrow \tau_2} = \arrow{\sem{\tau_1}}{\mon(\sem{\tau_2})} \and
\sem{\ind{\Sigma}(\tau)} = \mu X.(\sem{\tau} + F_\Sigma(\mon(X)))
\end{mathpar}
where $\mu X. F(X).$ represents the initial algebra of a suitable
endofunctor. For any Lawvere theory $L$,
$\mu X.T_L(\sem{\tau} + F_\Sigma(X))$ is isomorphic to to
$T_{(L + \sem{\Sigma})}$ \cite{hyland2006combining}. That means that
$\mon(\sem{\ind{\Sigma}(\glob \tau)})$ is isomorphic to the presheaf that
maps $L$ to $T_{(L + \sem{\Sigma})}(\sem{\tau}(\terminal))$, which in
turn is isomorphic to $\sem{\yoneda{\Sigma} \rightarrow \glob \tau}$ by the
result in the previous section. This isomorphism directly provides the
semantics of reflection and reification.

\begin{align*}
&\sem{\Gamma \vdash_V v \mathop{:} \tau} \mathrel{:} \sem{\Gamma} \rightarrow \sem{\tau} \\
&\sem{\glob \Gamma \vdash_V \mathop{\mathrm{box}} c \mathop{:} \glob \tau} = \glob \sem{\Gamma \vdash_C c \mathop{:} \tau}
\end{align*}
\begin{align*}
&\sem{\Gamma \vdash_C c \mathop{:} \tau} \mathrel{:} \sem{\Gamma} \rightarrow \mon(\sem{\tau}) \\
&\sem{\Gamma \vdash_C \mathop{\mathrm{return}} v \mathop{:} \tau} = \eta_{\sem{\tau}} \circ \sem{\Gamma \vdash_V v \mathop{:} \tau} \\
&\sem{\Gamma \vdash_C \mathop{\mathrm{let}} x : \tau_1 = c_1 \mathop{\mathrm{in}} c_2\mathop{:} \tau_2} = \mu_{\sem{\tau_2}} \circ \mon(\sem{\Gamma; x \mathop{:} \tau_1 \vdash_C C_2 \mathop{:} \tau_2}) \circ t_{\sem{\Gamma}, \sem{\tau_1}} \circ \langle id_{\sem{\Gamma}}, \sem{\Gamma \vdash_C C_1 \mathop{:} \tau} \rangle \\
&\sem{\Gamma \vdash_C \mathop{\mathrm{unbox}} c \mathop{:} \tau} = \mon(\epsilon_{\sem{\tau}}) \circ \sem{\Gamma \vdash_C c \mathop{:} \glob \tau} \\
&\sem{\Gamma \vdash_C \reflect{\Sigma}{c} \mathop{:} \yoneda{\Sigma} \rightarrow \glob \tau} = \reflect{\Sigma\tau}{\sem{\Gamma \vdash_C c \mathop{:} \ind{\Sigma}(\glob \tau)}} \\
&\sem{\Gamma \vdash_C \reify{\Sigma}{c} \mathop{:} \ind{\Sigma}(\glob \tau)} = \reify{\Sigma\tau}{\sem{\Gamma \vdash_C c \mathop{:} \yoneda{\Sigma} \rightarrow \glob \tau}} \\
\end{align*}
where $\eta$, $\mu$ and $t$ are the unit, multiplication and strength
respectively of $\mon$; $\epsilon$ is the counit of $\glob$;
$\reflect{\Sigma}{}$ and $\reify{\Sigma}{}$ are the natural
transformation in the isomorphism from the previous section.

\section{Implementation}
\label{sec:implementation}

\subsection{Implementation with untyped effect handlers}

We can implement the interface from Section \ref{sec:interface} directly
in terms of OCaml's untyped effect
handlers\cite{Sivaramakrishnan2021retrofitting}. The trick is to
generate a fresh effect constructor for each reification, pass that
constructor around as part of the \lstinline[style=ocaml]{handler}, and
then use it to perform operations during reflection.

\begin{lstlisting}[style=ocaml]
module Reflection (O : Op) = struct

  type 'a term =
    | Return : 'a @@ global -> 'a term
    | Op : 'r O.t @@ global * ('r -> 'a term) -> 'a term

  type handler = { perform : 'r. 'r O.t -> 'r }

  let reify f =
    let module Handler =
      struct type 'a Effect.t += H : 'a O.t -> 'a Effect.t end
    in
    let handler = { perform = fun o -> Effect.perform (Handler.H o) } in
    match f handler with
    | v -> Return v
    | effect Handler.H o, k -> Op(o, fun x -> Effect.continue k x)

  let reflect t =
    fun {perform} ->
      let rec loop = function
        | Return v -> v
        | Op(o, f) -> loop (f (perform o))
      in
      loop t

  let reify_local f = exclave
    let module Handler =
      struct type 'a Effect.t += H : 'a O.t -> 'a Effect.t end
    in
    let handler = { perform = fun o -> Effect.perform (Handler.H o) } in
    match f handler with
    | v -> Return v
    | effect Handler.H o, k -> Op(o, fun x -> Effect.continue k x)

  let reflect_local t = exclave
    fun {perform} ->
      let rec loop = function
        | Return v -> v
        | Op(o, f) -> loop (f (perform o))
      in
      loop t

end
\end{lstlisting}
Sums are then implemented by just lifting the injections on operations:
\begin{lstlisting}[style=ocaml]
module Sum (L : Op) (R : Op) = struct

  module Op = struct
    type 'a t =
      | Left : 'a L.t -> 'a t
      | Right : 'a R.t -> 'a t
  end    

  let outl {perform} =
    {perform = fun op -> perform (Left op)}

  let outr {perform} =
    {perform = fun op -> perform (Right op)}

end
\end{lstlisting}

\subsection{More efficient implementation in terms of fibers}

In the above implementation, whenever an operation is reflected we
perform a linear search up the stack of handlers until we find the
corresponding one. This search is not actually necessary...

\section{Related work}
\label{sec:related-work}

\section{Future work}
\label{sec:future-work}

\bibliography{references}
\bibliographystyle{plain}

\end{document}

