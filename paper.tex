\documentclass[acmsmall, screen, review, anonymous]{acmart}

\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{fontawesome5}
\usepackage{mathpartir}
\usepackage{sourcecodepro}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\lstset{
  basicstyle=\ttfamily\small,
  columns=fullflexible,
  keepspaces=true
}

\lstdefinestyle{oxcaml}{
  keywordstyle=\color{blue},
  emphstyle=\color{violet},
  language=[Objective]Caml,
  morekeywords={effect, exclave},
  escapeinside={(*@}{@*)},
  literate=
    {[]}{$\glob$}{1}
}

\lstdefinestyle{haskell}{
  keywordstyle=\color{blue},
  emphstyle=\color{violet},
  language=Haskell
}

\newcommand{\nat}{\mathbb{N}}
\newcommand{\glob}{\mathop{\Box}}
\newcommand{\cat}{\mathbb{C}}
\newcommand{\catobj}{C}
\newcommand{\op}{\mathtt{op}}
\newcommand{\catop}{\cat^{\op}}
\newcommand{\id}[1]{\mathrm{id}_{#1}}
\newcommand{\setc}{\mathrm{Set}}
\newcommand{\psh}{\widehat{\cat}}
\newcommand{\terminal}{\top}
\newcommand{\initial}{\bot}
\newcommand{\lawc}{\mathrm{Law}}
\newcommand{\lawcop}{\lawc^{\mathtt{op}}}
\newcommand{\pshlawcop}{\widehat{\lawcop}}
\newcommand{\freef}{Free}
\newcommand{\constfname}{\Omega}
\newcommand{\constf}[1]{\constfname #1}
\newcommand{\yonedaname}{y}
\newcommand{\yoneda}[1]{y(#1)}
\newcommand{\homset}[3]{\mathrm{Hom}_{#1}(#2, #3)}
\newcommand{\arrow}[2]{{#2}^{#1}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\reflectname}{\Uparrow}
\newcommand{\reflectraw}[1]{\mathop{\reflectname_{#1}}}
\newcommand{\reflect}[3]{\reflectraw{#1}(#2, #3)}
\newcommand{\reflectc}[2]{\mathop{\reflectname_{#1 #2}}}
\newcommand{\performraw}[2]{\mathop{\reflectname(#1(#2))}}
\newcommand{\perform}[5]{\performraw{#1}{#2}(#3, #4. #5)}
\newcommand{\reifyname}{\Downarrow}
\newcommand{\reifyraw}[1]{\mathop{\reifyname_{#1}}}
\newcommand{\reify}[3]{\reifyraw{#1}(#2.\,#3)}
\newcommand{\reifyc}[2]{\mathop{\reifyname_{#1 #2}}}
\newcommand{\outlname}{\mathrm{out}_L}
\newcommand{\outl}[1]{\mathop{\outlname} #1}
\newcommand{\outrname}{\mathrm{out}_R}
\newcommand{\outr}[1]{\mathop{\outrname} #1}
\newcommand{\mon}{\mathcal{T}}
\newcommand{\ind}[1]{W_{#1}}
\newcommand{\indintro}[4]{{#2}_{#1}(#3,\, #4)}
\newcommand{\retname}{\mathrm{ret}}
\newcommand{\ret}[2]{\mathop{\retname_{#1}}(#2)}
\newcommand{\indelimname}{\mathrm{rec}}
\newcommand{\indelim}[3]{\mathop{\indelimname_{#1}} #2 \,\{#3\}}
\newcommand{\indelimboxname}{\indelimname^{\glob}}
\newcommand{\indelimbox}[3]{\mathop{\indelimboxname_{#1}} #2 \,\{#3\}}
\newcommand{\indelimmname}{\indelimname^{m}}
\newcommand{\indelimm}[3]{\mathop{\indelimmname_{#1}} #2 \,\{#3\}}
\newcommand{\indretcase}[2]{\retname(#1) \Rightarrow #2}
\newcommand{\indcase}[4]{#1(#2, #3) \Rightarrow #4}
\newcommand{\letret}[4]{\mathop{\mathrm{let}} (\ret{#1}{#2}) = #3 \mathop{\mathrm{in}} #4}
\newcommand{\seq}{\,;\,}
\newcommand{\fst}{\mathop{\pi_1}}
\newcommand{\snd}{\mathop{\pi_2}}
\newcommand{\inl}[1]{\mathop{\mathrm{in}_L} #1}
\newcommand{\inr}[1]{\mathop{\mathrm{in}_R} #1}
\newcommand{\casename}{\mathrm{case}}
\newcommand{\case}[5]{\mathop{\casename} #1 \,\{\,\inl{#2} \Rightarrow #3 \seq \inr{#4} \Rightarrow #5 \,\}}
\newcommand{\casemname}{\casename^{m}}
\newcommand{\casem}[5]{\mathop{\casemname} #1 \,\{\,\inl{#2} \Rightarrow #3 \seq \inr{#4} \Rightarrow #5 \,\}}
\newcommand{\caseboxname}{\casename^{\glob}}
\newcommand{\casebox}[5]{\mathop{\caseboxname} #1 \,\{\,\inl{#2} \Rightarrow #3 \seq \inr{#4} \Rightarrow #5 \,\}}
\newcommand{\abs}[3]{\mathop{\lambda}(#1 \types #2).\,#3}
\newcommand{\app}[2]{#1\,#2}
\newcommand{\types}{\mathrel{:}}
\newcommand{\mtypes}{\mathrel{:_{m}}}
\newcommand{\gtypes}{\mathrel{:_{\Box}}}
\newcommand{\cempty}{\varepsilon}
\newcommand{\ccons}[2]{#1;\,#2}
\newcommand{\lbind}[3]{\ccons{#1}{#2\types#3}}
\newcommand{\mbind}[3]{\ccons{#1}{#2\mtypes#3}}
\newcommand{\gbind}[3]{\ccons{#1}{#2\gtypes#3}}
\newcommand{\cdiv}[1]{#1/\Box}
\newcommand{\cmdiv}[1]{#1/m}
\newcommand{\cldiv}[1]{#1/\text{\textvisiblespace}}}
\newcommand{\bdiv}[1]{\cdiv{\mathop{!_{#1}}}}
\newcommand{\return}[1]{\mathop{\mathrm{return}} #1}
\newcommand{\letv}[3]{\mathop{\mathrm{let}} #1 = #2 \mathop{\mathrm{in}} #3}
\newcommand{\gbox}[1]{\mathop{\mathrm{box}} #1}
\newcommand{\gunbox}[3]{\mathop{\mathrm{let}} (\gbox{#1}) = #2 \mathop{\mathrm{in}} #3}
\newcommand{\grun}[1]{\mathop{\mathrm{run}}(#1)}
\newcommand{\sbst}[3]{#1[#2\backslash#3]}
\newcommand{\turnv}{\mathrel{\vdash_V}}
\newcommand{\turnc}{\mathrel{\vdash_C}}
\newcommand{\evmap}{\mathop{ev}}
\newcommand{\currymap}{\mathop{\lambda}}
\newcommand{\reducestov}{\rightsquigarrow_V}
\newcommand{\reducestoc}{\rightsquigarrow_C}
\newcommand{\mif}{\mathop{\mathrm{if}}}
\newcommand{\mthen}{\mathop{\mathrm{then}}}
\newcommand{\melse}{\mathop{\mathrm{else}}}
\newcommand{\embed}[1]{\mathopen{\lbag}#1\mathclose{\rbag}}
\newcommand{\ctxeq}{\cong_{\mathrm{ctx}}}

\newcommand{\todo}[1]{{\color{red}TODO: #1}}

\title{Locality and Effect Reflection}
\author{Leo White}
\affiliation{\institution{Jane Street}\country{UK}}
\date{}
\setcopyright{none}

\begin{document}

\begin{abstract}
  Programming languages increasingly support algebraic effects and
  handlers for writing effectful code in a principled way by extending a
  language's \emph{ambient monad} \textbf{--} the monad describing which
  effects ordinary functions can perform \textbf{--} with additional
  effectful operations. However, integrating effects into type systems
  typically requires specialized effect systems that add complexity to
  the language.

  We introduce \emph{effect reflection}, an alternative presentation of
  algebraic effects and handlers that provides, for any algebraic
  signature $\Sigma$ and type $\tau$, an isomorphism:
  \begin{equation*}
    \ind{\Sigma}(\tau)
    \qquad \cong \qquad
    \yoneda{\Sigma} \rightarrow \glob \tau
  \end{equation*}

  where $\ind{\Sigma}(\tau)$ is the free algebra of $\Sigma$ at
  $\tau$, $\yoneda{\Sigma}$ is a type representing how to inject
  terms of $\Sigma$ into the current ambient monad, and $\glob$ is a
  comonadic \emph{global modality} used to track which values do not
  depend on the ambient monad. $\ind{\Sigma}$ is sometimes called the
  \emph{freer monad} of $\Sigma$. This isomorphism emerges naturally
  from the \emph{ambient monad model}, a novel semantic model of
  algebraic effect handlers in terms of presheaves over bounded Lawvere
  theories.

  Effect reflection provides all the expressiveness of typed algebraic
  effects without requiring language-level support for effect systems. We
  demonstrate this by implementing effect reflection as a library in
  OxCaml~\cite{lorenzen2024oxidizing} and showing how classic effectful
  programs can be written in natural direct style.
\end{abstract}

\maketitle

\section{Reflection for algebraic effects}

\subsection{Algebraic effects}
Algebraic effects and handlers have emerged as a powerful approach to
structured programming with effects. Handlers allow the programmer to
temporarily extend the \emph{ambient monad} of their language -- the
monad describing which effects an ordinary function can perform -- with
additional effectful operations.

For example, in OCaml, one can write:
\begin{lstlisting}[style=oxcaml]
  type 'a Effect.t +=
    | Get : int Effect.t
    | Set : int -> unit Effect.t

  let handle_state (f : unit -> 'a) : 'a =
    match f () with
    | x -> fun _ -> x
    | effect Get, k -> fun s -> continue k s s
    | effect Set s', k -> fun _ -> continue k () s'
\end{lstlisting}
and for the duration of the \lstinline[style=oxcaml]{f ()} function call
the ambient monad is extended with two additional effectful operations:
\begin{lstlisting}[style=oxcaml]
  let get () : int = perform Get
  let set (i : int) : unit = perform (Set i)
\end{lstlisting}

However, effect handlers face a fundamental tension: \emph{untracked}
effects are unsafe, while \emph{tracked} effects require complex type
system extensions.

In OCaml, the effects are untracked: nothing prevents attempting to
perform an algebraic effect operation that is not supported by the
current ambient monad, resulting in an
\lstinline[style=oxcaml]{Unhandled} exception being raised.

In languages like Koka~\cite{leijen2017type} the type system is extended
to explicitly track the effects that a function may perform. This
prevents the unsafety on an unhandled effect but adds complexity to the
language.

The ``effects as capabilities'' approach of the Effekt
language~\cite{brachthauser2020effects} points the way by elegantly
tracking effects without requiring explicit effect-tracking machinery in
the type system. However, it is restricted to second-class
functions\footnote{That restriction is lifted in more recent work on Effekt~\cite{brachthauser2022effects}, but only by falling back to explicit
effect-tracking machinery.}. We aim to extend this approach to first
class functions.

\subsection{Locality and effect reflection}
Locality captures the general idea of a value depending on some notion
of ``location''. Our key insight is that the ambient monad can be viewed
as a form of location, allowing us to reuse existing type system
features for tracking locality.

We can represent locality in a type system using a comonadic
\emph{global modality} $\glob$ that tracks which values do \emph{not}
depend on their location. Values of an ordinary type $\tau$ are assumed
to potentially depend on the current location, whereas values of the
global type $\glob \tau$ are known not to.

In our setting being global means not depending on the ambient
monad. For example, $A \rightarrow B$ represents computations that may
use operations from the ambient monad, while $\glob (A \rightarrow B)$
contains only pure computations that ignore the ambient monad.

Based on this relationship between locality and effects, we present
\emph{effect reflection}, providing, for any algebraic signature
$\Sigma$ and type $\tau$, an isomorphism:
\begin{equation*}
  \ind{\Sigma}(\tau)
  \qquad \cong \qquad
  \yoneda{\Sigma} \rightarrow \glob \tau
\end{equation*}
where $\ind{\Sigma}(\tau)$ is an inductive type representing the
free algebra of $\Sigma$ at $\tau$, and $\yoneda{\Sigma}$ is a
type representing how to inject terms of $\Sigma$ into the current
ambient monad. $\ind{\Sigma}$ is sometimes called the \emph{freer monad}
of $\Sigma$~\cite{kiselyov2015freer}.

This isomorphism reveals that effectful computations can be represented
as ordinary functions, enabling direct-style programming with full
effect safety.

\subsection{Effect reflection in OxCaml}
OxCaml~\cite{lorenzen2024oxidizing} provides type system support for
tracking locality and runtime support for algebraic effects. For
backwards compatibility with OCaml, an unadorned arrow type
\lstinline[style=oxcaml]{t -> s} is treated as if the parameter and
return types were actually \lstinline[style=oxcaml]{[]t} and
\lstinline[style=oxcaml]{[]s}. To get parameters or results that are not
implicitly global we write \lstinline[style=oxcaml]{@ local} on them,
e.g. \lstinline[style=oxcaml]{t @ local -> s @ local}.

Using this support, we can provide effect reflection as a simple API.
We represent algebraic signatures as modules with a single type
constructor, providing $\ind{\Sigma}$ as
\lstinline[style=oxcaml]{'a Term(Sigma).t} and $\yoneda{\Sigma}$ as
\lstinline[style=oxcaml]{Handler(Sigma).t}.

For example, we can use it to write an effect handler equivalent to the
OCaml one above:
\begin{lstlisting}[style=oxcaml]
  module State = struct
    type 'a t =
      | Get : int t
      | Set : int -> unit t
  end

  module State_eff = Reflection(State)

  let handle_state (f : Handler(State).t @ local -> 'a) (i : int) : 'a =
    let rec loop (s : int) : 'a Term(State).t @ local -> 'a  = function
      | Return x -> x
      | Op(Get, k) -> loop s (State_eff.continue_local k s)
      | Op(Set s', k) -> loop s' (State_eff.continue_local k ())
    in
    loop i (State_eff.reify_local f)
\end{lstlisting}
which calls \lstinline[style=oxcaml]{f} and passes it a local value of
type \lstinline[style=oxcaml]{Handler(State).t}. For the duration of the
call to \lstinline[style=oxcaml]{f} the ambient monad is extended with
two additional effectful operations, which can be used via reflection:
\begin{lstlisting}[style=oxcaml]
  let get (h : Handler(State).t @ local) : int =
    State_eff.perform Get h

  let set (h : Handler(State).t @ local) (i : int) : unit =
    State_eff.perform (Set i) h
\end{lstlisting}

The locality of the \lstinline[style=oxcaml]{Handler(State).t} value
passed to \lstinline[style=oxcaml]{f} ensures that these operations can
only be performed when available in the ambient monad. The type system
prevents this handler value from escaping the scope of
\lstinline[style=oxcaml]{f}, which in turn prevents
\lstinline[style=oxcaml]{get} or \lstinline[style=oxcaml]{set} from
being called outside that scope.

\subsection{The ambient monad model}

This design emerges naturally from a semantic model of algenbraic
effects where types are interpreted as presheaves over \emph{bounded
  Lawvere theories} -- a categorical framework that makes the connection
between locality and effects precise.

The key idea is to index the semantics by the ambient monad: rather than
interpreting types as sets, we interpret them as functions from ambient
monads to sets. We represent ambient monads by their corresponding
algebraic theories using bounded Lawvere theories.

The key constructs of effect reflection are then defined as follows:
\begin{itemize}
\item Computations can be represented as a monad $\mon$ on such
  presheaves, which maps each algebraic theory to its free algebras.

\item The global modality $\glob P$ is defined as the constant presheaf
  that always ignores the ambient monad and instead returns
  $P(\initial)$, where $\initial$ is the algebraic theory with no
  operations or equations.

\item The semantics of our handler types $\yoneda{\Sigma}$ are given by
  the Yoneda embedding

\item The effect reflection isomorphism becomes a simple consequence of
  the Yoneda lemma and a key property of the sums of algebraic theories.
\end{itemize}

\subsection{Structure of the paper} We proceed as follows:
\begin{itemize}
\item In Section \ref{sec:practice}, we give an overview of effect reflection in
  practice in OxCaml.
\item In Section \ref{sec:language}, we define a simply typed calculus featuring
  effect reflection.
\item In Section \ref{sec:semantics}, we describe our denotational
  semantics of effect reflection.
\item In Section \ref{sec:implementation}, we give an implementation of effect
  reflection in OxCaml in terms of the untracked algebraic effects it
  inherits from OCaml.
\item In Section \ref{sec:related-work}, we discuss related work.
\end{itemize}

\section{Effect reflection in practice}
\label{sec:practice}

We provide effect reflection as a simple library API in OxCaml. In this
section we describe this API and show how to use it to write typical
examples of algebraic effects.

\subsection{Locality in OxCaml}

The effect reflection API relies on OxCaml's support for tracking
locality in types, which we describe here. For a full treatment see
Lorenzen et al.~\cite{lorenzen2024oxidizing}.

Values in OxCaml are associated with both a type -- which describes how
values can be introduced and eliminated -- and a \emph{mode} -- which
tracks properties related to operations other than introduction and
elimination. Modes are a product of a number of different axes, tracking
a variety of different properties, but here we are only interested in
one of them: \emph{locality}. Ignoring the other axes, a mode is either
\lstinline[style=oxcaml]{local} or \lstinline[style=oxcaml]{global}.

Locality tracks whether a value can escape the current
\emph{region}. By default, the current region ends when a function
returns, so local values cannot be returned from functions.
\begin{lstlisting}[style=oxcaml]
  let leak_local x =
    let (o @ local) = Some x in
    o
  (*@ \textcolor{red}{Error: o} @*)
         (*@ \textcolor{red}{\textasciicircum} @*)
  (*@ \textcolor{red}{This value escapes its region.} @*)
\end{lstlisting}
The \lstinline[style=oxcaml]{exclave} construct allows functions to
return local values.
\begin{lstlisting}[style=oxcaml]
  let return_local x =
    exclave
      (let (o @ local) = Some x in
       o)
\end{lstlisting}
\lstinline[style=oxcaml]{exclave e} can only appear in tail position
within a function.  It ends the function's region early and then
executes the expression \lstinline[style=oxcaml]{e}. Since
\lstinline[style=oxcaml]{e} is executed within the region of the caller
of the function, any local values created within it can be safely
returned to that caller.

Arrow types are labelled with two modes: one for the argument and one
for the return value.
\begin{lstlisting}[style=oxcaml]
  val return_local : 'a @ local -> 'a option @ local
\end{lstlisting}
For convenience, and backwards compatibility with OCaml, either mode can
be omitted, in which case it defaults to
\lstinline[style=oxcaml]{global}.

By default, modes are deep: a local
\lstinline[style=oxcaml]{string list} is a local list of local
strings. However, the depth that a mode applies can be controlled via
\emph{modalities}. Record fields can be annotated with the
\lstinline[style=oxcaml]{global} modality to indicate that the contents
of the field are global even when the surrounding record is local. For
example:
\begin{lstlisting}[style=oxcaml]
  type 'a gbl = { g : 'a @@ global }
\end{lstlisting}
gives a record whose only field has the \lstinline[style=oxcaml]{global}
modality. The contents of the \lstinline[style=oxcaml]{g} field is always
global, for example:
\begin{lstlisting}[style=oxcaml]
  let project_global (r @ local) =
    r.g
\end{lstlisting}
gives a function of type:
\begin{lstlisting}[style=oxcaml]
  val project_global : 'a gbl @ local -> 'a @ global
\end{lstlisting}
Variant constructor arguments can also be annotated with modalities.

Note that, whilst there is a \lstinline[style=oxcaml]{global} modality,
there is no \lstinline[style=oxcaml]{local} modality. It does not make
sense for a value which has the ability to leave a region to contain a
value which doesn't have that ability: when the first value leaves a
region it will implicitly cause the second one to leave that region as
well. This means the \lstinline[style=oxcaml]{global} mode is always
deep.

\subsection{Effect reflection interface}
\label{sec:interface}

The types and operations of our effect reflection API are parameterized
by type constructors representing the operations of an algebraic
effect. In OxCaml, such higher-kinded interfaces must be built using
functors. We start with a simple module type
\lstinline[style=oxcaml]{Op} to act as the parameter type for these
functors:
\begin{lstlisting}[style=oxcaml]
  module type Op = sig type 'a t end
\end{lstlisting}
The fundamental types of the API are the \lstinline[style=oxcaml]{Term}
and \lstinline[style=oxcaml]{Handler} types.
\begin{lstlisting}[style=oxcaml]
  module Continuation(O : Op) : sig
    type ('a, 'b) t
  end

  module Term (O : Op) : sig
    type 'a t =
      | Return : 'a @@ global -> 'a t
      | Op : 'r O.t @@ global * ('r, 'a) Continuation(O).t -> 'a t
  end

  module Handler(O : Op) : sig
    type t
  end
\end{lstlisting}
These types directly implement the types from our core isomorphism.
\lstinline[style=oxcaml]{'a Term(Sigma).t} corresponds to
$\ind{\Sigma}(\tau)$ and represents terms in the free algebra of
\lstinline[style=oxcaml]{Sigma}. \lstinline[style=oxcaml]{Handler(Sigma).t}
corresponds to $\yoneda{\Sigma}$ and represents algebraic effect
handlers handling \lstinline[style=oxcaml]{Sigma} in the current
computation.

\lstinline[style=oxcaml]{('a, 'b) Continuation(Sigma).t} is equivalent
to \lstinline[style=oxcaml]{'a -> 'b Term(Sigma).t} when global and
equivalent to \lstinline[style=oxcaml]{'a -> 'b Term(Sigma).t @ local}
when local. This ensures that the global modality distributes over
\lstinline[style=oxcaml]{Term(Sigma).t}, which is an important property
of $\ind{\Sigma}$. The need for it is an artifact of OxCaml's approach
to locality: the global modality does not distribute over the function
arrow in OxCaml. In the language we describe in
Section~\ref{sec:language} it is replaced with an ordinary function
type.

The main piece of the API is a family of isomorphisms:
\begin{equation*}
  \text{\lstinline[style=oxcaml]{'a Term(O).t}} \qquad
  \cong \qquad \text{\lstinline[style=oxcaml]{Handler(O).t @ local -> 'a}}
\end{equation*}
We expose this isomorphism as three functions:
\begin{lstlisting}[style=oxcaml]
  module Reflection (O : Op) : sig
    val reify : (Handler(O).t @ local -> 'a) -> 'a Term(O).t

    val continue : ('a, 'b) Continuation(O).t -> 'a -> 'b Term(O).t

    val reify_local :
      (Handler(O).t @ local -> 'a) @ local -> 'a Term(O).t @ local

    val continue_local :
      ('a, 'b) Continuation(O).t @ local -> 'a -> 'b Term(O).t @ local

    val perform : 'a O.t -> (Handler(O).t @ local -> 'a)
  end
\end{lstlisting}
\lstinline[style=oxcaml]{reify} and
\lstinline[style=oxcaml]{reify_local} implement the left-to-right
direction of the isomorphism. We need two separate functions because
OxCaml lacks any form of mode polymorphism.

\lstinline[style=oxcaml]{perform} is equivalent to the right-to-left
direction of the isomorphism but is a more convenient primitive in
practice. It amounts to reflection of individual operations as opposed
to full terms. We can implement reflection of global full terms as:
\begin{lstlisting}[style=oxcaml]
  let rec reflect t h =
    match t with
    | Return x -> x
    | Op(op, k) -> reflect (continue_local k (perform op h)) h
\end{lstlisting}
with type:
\begin{lstlisting}[style=oxcaml]
  val reflect : 'a Term(O).t -> (Handler(O).t @ local -> 'a)
\end{lstlisting}
Reflection of local terms can be defined similarly.

\subsection{Example: State}

As shown in the introduction we can implement an effect handler for
state using this API. We start by defining the operations of the effect:
\begin{lstlisting}[style=oxcaml]
  module State = struct
    type 'a t =
      | Get : int t
      | Set : int -> unit t
  end
\end{lstlisting}
Then we instantiate the reflection isomorphism for that effect and use
it to write a handler:
\begin{lstlisting}[style=oxcaml]
  module State_eff = Reflection(State)
  open Term(State)

  let handle_state i f =
    let rec loop (s : int) = function
      | Return x -> x
      | Op(Get, k) -> loop s (State_eff.continue_local k s)
      | Op(Set s', k) -> loop s' (State_eff.continue_localk ())
    in
    loop i (State_eff.reify_local f)
\end{lstlisting}
Finally we add an alias for the handler type and some convenient
wrappers for the generic effects:
\begin{lstlisting}[style=oxcaml]
  type handler = Handler(State).t

  let get h =
    State_eff.perform Get h

  let set h i =
    State_eff.perform (Set i) h
\end{lstlisting}
Giving us the following interface:
\begin{lstlisting}[style=oxcaml]
  type handler

  val handle_state : int -> (handler @ local -> 'a) @ local -> 'a
  val get : handler @ local -> int
  val set : handler @ local -> int -> unit
\end{lstlisting}
Note that we are able to use \lstinline[style=oxcaml]{reify_local} to
allow the function passed to \lstinline[style=oxcaml]{handle_state} to
be local.

This shows how to implement state using effect reflection, but note that
the same interface can also be implemented directly in OxCaml using
mutable state and locality:
\begin{lstlisting}[style=oxcaml]
  type handler = int ref

  let handle_state i f = f (ref i)
  let get r = !r
  let set r i = r := i
\end{lstlisting}
This implementation gives the same behaviour as the one built using
effect reflection. Crucially it is just as easy to reason about, which
in turn means it is just as easy to reason about as the state
monad. This shows that the improved reasoning ability of the state monad
over ordinary mutable state is precisely captured by the notion of
locality.

This transformation from effect reflection to local mutable state works
for any \emph{tail-resumptive}\cite{??} effect handler.

\subsection{Lightweight effect polymorphism}

The following function uses state to calculate the total of a list of
integers:
\begin{lstlisting}[style=oxcaml]
  let total l =
    handle_state 0 (fun h ->
      List.iter (fun x -> set h (get h + x)) l;
      get h)
\end{lstlisting}
This relies on the locality of the function parameter of
\lstinline[style=oxcaml]{List.iter}:
\begin{lstlisting}[style=oxcaml]
  val iter : ('a -> unit) @ local -> 'a list -> unit
\end{lstlisting}
The \lstinline[style=oxcaml]{local} annotation on the parameter ensures
that any function passed will not escape the current region. This allows
us to pass in a closure that closes over the
\lstinline[style=oxcaml]{local} handler \lstinline[style=oxcaml]{h} and
use it to perform some effects.

This ability for higher-order functions like
\lstinline[style=oxcaml]{List.iter} to be reused with different ambient
monads achieves the ``lightweight effect polymorphism'' described by
Brachth{\"a}user et al.~\cite{brachthauser2020effects} without requiring
second-class functions -- locality provides the necessary restrictions
while maintaining first-class status.

\subsection{Example: Generators}

A more realistic use of effect reflection is a \emph{generator}
effect. This effect has a single operation:
\begin{lstlisting}[style=oxcaml]
  module Gen = struct
    type 'a t =
      | Gen : int -> unit t
  end
\end{lstlisting}
Along with a handler that turns computations using
\lstinline[style=oxcaml]{Gen} into streams of integers.
\begin{lstlisting}[style=oxcaml]
  module Gen_eff = Reflection(Gen)
  open Term(Gen)

  type ints =
    | Finished
    | More of int * (unit -> ints)

  let handle_gen f =
    let rec loop = function
      | Return () -> Finished
      | Op(Gen i, k) -> More(i, fun () -> loop (Gen_eff.continue k ()))
    in
    loop (Gen_eff.reify f)
\end{lstlisting}

Unlike the state handler, here we must use
\lstinline[style=oxcaml]{reify} rather than
\lstinline[style=oxcaml]{reify_local} because our intention is that the
resulting stream of integers be a global value that can escape the
current region. Since it closes over the continuation
\lstinline[style=oxcaml]{k}, we must use \lstinline[style=oxcaml]{reify}
and require that \lstinline[style=oxcaml]{f} be global:
\begin{lstlisting}[style=oxcaml]
  val handle_gen : (Handler(Gen).t @ local -> unit) -> ints
\end{lstlisting}

\subsection{Example: Asynchronous I/O}

Perhaps the most common use case for algebraic effects is for
concurrency and asynchronous I/O. Implementing asynchronous I/O from
scratch is beyond the scope of this paper, but we can build a simple
version on top of an existing monadic concurrency library. Assuming we
have a monadic future type \lstinline[style=oxcaml]{'a Deferred.t} we can
write concurrent code in direct style by using an effect with a single
\lstinline[style=oxcaml]{Await} operation that waits for a future to be
completed:
\begin{lstlisting}[style=oxcaml]
  module Await : sig
    type 'a t =
      | Await : 'a Deferred.t -> 'a t
  end
\end{lstlisting}

\begin{lstlisting}[style=oxcaml]
  module Await_eff = Reflection(Await)
  open Term(Await)

  let handle_await f =
    let rec loop = function
      | Return x -> Deferred.return x
      | Op(Await d, k) ->
          Deferred.bind d (fun x -> loop (Await_eff.continue k x))
    in
    loop (Await_eff.reify f)

  let await h d =
    Await_eff.perform (Await d) h
\end{lstlisting}

Using this we can write direct-style code using asynchronous I/O:
\begin{lstlisting}[style=oxcaml]
  let copy_file h src dst =
    let s = await h (File.read src) in
    await h (File.write dst s)
\end{lstlisting}

\subsection{One-shot continuations}

For various practical reasons, OCaml's algebraic effects are restricted
to only allow continuations to be resumed a single time. This rules out
interesting effects like backtracking search, but improves the ability
to reason about the interaction of effects and resources.

There is no fundamental reason that effect reflection should be
restricted to only one-shot continuations, so for the purposes of this
paper we shall ignore the restriction. However, for the same reasons as
OCaml, our actual implementation is restricted one-shot
continuations. Note that OxCaml's \lstinline[style=oxcaml]{once}
mode~\cite{lorenzen2024oxidizing} allows us to enforce this restriction
statically.

\subsection{Nested effect handlers}

A key feature of algebraic effects is how easily they compose. We can
use state whilst using asynchronous I/O by simply nesting their
handlers:
\begin{lstlisting}[style=oxcaml]
  handle_await (fun ah ->
    handle_state i (fun sh ->
      List.iter (fun fl ->
        let s = await ah (File.read fl) in
        let i = int_of_string s in
        set sh (i + get sh)) files;
      get sh))
\end{lstlisting}

This relies on the fact that the \lstinline[style=oxcaml]{handle_state}
uses \lstinline[style=oxcaml]{reify_local} and so is able to operate on a
local computation that closes over the local await handler value
\lstinline[style=oxcaml]{ah}.

If we tried to do something similar using our
\lstinline[style=oxcaml]{handle_gen} handler, then we get an error:
\begin{lstlisting}[style=oxcaml]
  handle_await (fun ah ->
    handle_gen (fun gh ->
      List.iter (fun fl ->
        let s = await ah (File.read fl) in
        let i = int_of_string s in
        gen gh i) files))
  (*@ \textcolor{red}{Error: let s = await ah (File.read fl) in} @*)
                       (*@ \textcolor{red}{\textasciicircum\textasciicircum} @*)
  (*@ \textcolor{red}{ This value is local and would escape its region.} @*)
\end{lstlisting}

We could change the definition of \lstinline[style=oxcaml]{handle_gen}
to use \lstinline[style=oxcaml]{reify_local} instead of
\lstinline[style=oxcaml]{reify}, but then we would lose the property
that the generator we produce can be passed around freely. Instead we
need to build a handler that can \emph{forward} the
\lstinline[style=oxcaml]{Await} operation to different effect handlers
at different points in the program's execution.

\subsection{Effect sums and effect forwarding}

Composing handlers like \lstinline[style=oxcaml]{handle_gen}, that use
\lstinline[style=oxcaml]{reify} rather than
\lstinline[style=oxcaml]{reify_local}, is a fundamentally more involved
operation. Consider the case of generators that are able to use
asynchronous I/O. We are given a computation that performs both
\lstinline[style=oxcaml]{Await} and \lstinline[style=oxcaml]{Gen}
operations and we'd like to turn it into a stream of integers.  We would
like to be able to freely pass this stream around. In particular, we do
not wish the stream to be prevented from escaping the scope of the
current \lstinline[style=oxcaml]{Await} handler.  However forcing parts
of the stream requires performing additional
\lstinline[style=oxcaml]{Await} operations, so whenever we force part of
the stream we'll need to provide a handler for those
\lstinline[style=oxcaml]{Await} operations again.

To achieve this more general form of composition, we require an
additional capability in our effect reflection API. We need to be able
to manipulate \lstinline[style=oxcaml]{Handler} types for sums of
effects.
\begin{lstlisting}[style=oxcaml]
  module Sum (L : Op) (R : Op) : sig
    type 'a t =
      | Left : 'a L.t -> 'a t
      | Right : 'a R.t -> 'a t
  end

  module Project(L : Op) (R : Op) : sig
    val outl : Handler(Sum(L)(R)).t @ local -> Handler(L).t @ local

    val outr : Handler(Sum(L)(R)).t @ local -> Handler(R).t @ local
  end
\end{lstlisting}

We can now write our desired handler for the
\lstinline[style=oxcaml]{Gen} effect by instead writing a handler for
\lstinline[style=oxcaml]{Sum(Await)(Gen)} that forwards all the
\lstinline[style=oxcaml]{Await} operations on to another handler.

\begin{lstlisting}[style=oxcaml]
  module Eff = Reflection(Sum(Await)(Gen))
  module Proj = Project(Await)(Gen)

  type aints =
    | Finished
    | More of int * (Handler(Await).t @ local -> aints)

  let handle_gen_in_await f ah =
    let rec loop ah = function
      | Return () -> Finished
      | Op(Left op, k) -> loop ah (Eff.continue k (perform ah op))
      | Op(Right(Gen i), k) ->
          More(i, fun ah -> loop ah (Eff.continue k ()))
    in
    loop ah (Eff.reify (fun h -> f (Proj.outl h) (Proj.outr h))
\end{lstlisting}

The need for effect forwarding is a general short-coming of lexical
handlers that applies to all such systems. Examples like this
fundamentally require that performing an \lstinline[style=oxcaml]{Await}
operation does work proportional to the number of handlers it is
forwarded through. Lexical handlers do a constant amount of work to
perform operations and so cannot handle such examples
directly. Non-lexical effect handlers \textbf{always} do work
proportional to the number of nested handlers, allowing them to support
such examples directly but paying a higher cost for the cases that do
not need forwarding.

\section{A language with effect reflection}
\label{sec:language}

The design of effect reflection falls out naturally from a denotational
semantics in terms of presheaves. To make this connection precise and
demonstrate the key properties of effect reflection, we present a
simply-typed calculus that directly incorporates the constructs needed
for effect reflection.

\subsection{The base language}

Our language is simply typed, featuring all the usual type-formers. It
uses a variation of fine-grained call-by-value: it has separate syntax
and typing judgements for values and computations. The syntax and typing
rules for the base language are shown in Fig.\ref{fig:typing-standard}.
\begin{figure}
\begin{align*}
  \mathrm{types}, \tau ::=\;& \tau \times \tau \mid 1 \mid \tau + \tau
                              \mid \tau \rightarrow \tau \mid \ldots \\
  \mathrm{contexts}, \Gamma ::=\;& \cempty \mid \mbind{\Gamma}{x}{\tau} \mid \ldots \\
  \mathrm{values}, v :=\;& x \mid (v, v) \mid \fst v \mid \snd v
                           \mid () \mid \inl{v} \mid \inr{v} \mid \abs{x}{\tau}{c}
                           \mid \case{v}{x}{v}{x}{v} \ldots \\
  \mathrm{computations}, c :=\;& \return{v} \mid \letv{x}{c}{c}
                                 \mid \app{v}{v} \mid \ldots
\end{align*}
\begin{mathpar}
\inferrule{\\}
{\lbind{\Gamma}{x}{\tau} \turnv x \types \tau}
\and
\inferrule{\Gamma \turnv v_1 \types \tau_1 \\ \Gamma \turnv v_1 \types \tau_1}
{\Gamma \turnv (v_1, v_2) \types \tau_1 \times \tau_2}
\and
\inferrule{\Gamma \turnv v \types \tau_1 \times \tau_2}
{\Gamma \turnv \fst{v} \types \tau_1}
\and
\inferrule{\Gamma \turnv v \types \tau_1 \times \tau_2}
{\Gamma \turnv \snd{v} \types \tau_2}
\and
\inferrule{\\}
{\Gamma \turnv () \types 1}
\and
\inferrule{\Gamma \turnv v \types \tau_1}
{\Gamma \turnv \inl{v} \types \tau_1 + \tau_2}
\and
\inferrule{\Gamma \turnv v \types \tau_2}
{\Gamma \turnv \inr{v} \types \tau_1 + \tau_2}
\and
\inferrule{\Gamma \turnv v_1 \types \tau_1 + \tau_2 \\
           \lbind{\Gamma}{x_1}{\tau_1} \turnv v_2 \types \tau_3 \\
           \lbind{\Gamma}{x_2}{\tau_2} \turnv v_3 \types \tau_3}
{\Gamma \turnv \case{v_1}{x_1}{v_2}{x_2}{v_3} \types \tau_3}
\and
\inferrule{\lbind{\Gamma}{x}{\tau_1} \turnc c \types \tau_2}
{\Gamma \turnv \abs{x}{\tau_1}{c} \types \tau_1 \rightarrow \tau_2}
\and
\inferrule{\Gamma \turnv v \types \tau}
{\Gamma \turnc \return{v} \types \tau}
\and
\inferrule{\Gamma \turnc c_1 \types \tau_1 \\
           \lbind{\Gamma}{x}{\tau_1} \turnc c_2 \types \tau_2}
{\Gamma \turnc \letv{x}{c_1}{c_2} \types \tau_2}
\and
\inferrule{\Gamma \turnv v_1 \types \tau_1 \rightarrow \tau_2 \\
           \Gamma \turnv v_2 \types \tau_1}
{\Gamma \turnc v_1 v_2 \types \tau_2}
\end{mathpar}
\caption{Basic syntax and typing rules}
\label{fig:typing-standard}
\end{figure}

Note that $\casename$ -- the eliminator for sum types -- is a value
rather than a computation. We can define a computation version as:
\begin{align*}
    &\case{v}{x_1}{c_1}{x_2}{c_2} := \\
    &\qquad (\case{v}{x_1}{\abs{\_}{1}{c_1}}{x_2}{\abs{\_}{1}{c_2}}) \; ()
\end{align*}

\subsection{Locality}

We track locality in the language via a global comonadic modality
$\glob$. In our setting being global means not depending on the ambient
monad. For example, $1 \rightarrow 1$ represents computations that may
use operations from the ambient monad, while $\glob (1 \rightarrow 1)$
contains only pure computations that ignore the ambient monad.

When using $\gbox{v}$ to build a value with a global type, we can only
use existing values that also have a global type. We achieve this using
a fairly standard approach for modal types: we extend contexts with a
binding form that requires a global type and then we restrict the
context in which we type $v$ to only include such bindings. The new
global binding form is written $\gbind{\Gamma}{x}{\tau}$ and represents
a value in the context of type $\glob \tau$. We create global bindings
in the context using the elimination form: $\gunbox{x}{v_1}{v_2}$.

Restricting the context is implemented via an operation on contexts
$\cdiv{\Gamma}$ that removes all local bindings, leaving only the global
ones:
\begin{align*}
  &\cdiv{\cempty} = \cempty \\
  &\cdiv{(\lbind{\Gamma}{x}{\tau})} = \cdiv{\Gamma} \\
  &\cdiv{(\gbind{\Gamma}{x}{\tau})} = \gbind{\cdiv{\Gamma}}{x}{\tau}
\end{align*}

Global computations do not depend on the ambient monad, so we also
include a value form $\grun{c}$, which allows treating a global
computation $c$ as a value.

The global comonad distributes over sum types:
\begin{equation*}
  \glob (\tau_1 + \tau_2)
  \qquad \cong \qquad
  (\glob \tau_1) + (\glob \tau_2)
\end{equation*}
which we realize via $\caseboxname$, a global form of the
$\casename$ construct, which allows you to match on a global sum and get
out global components.

We also add a modalities category, $m$, to the syntax, which is either
blank space or $\glob$, to make it easier to describe rules that are
parametric in the presence or absence of the global modality. As part of
this, the $\cdiv{\Gamma}$ operation is extended to work on modalities
$\cmdiv{\Gamma}$ with $\cldiv{\Gamma} = \Gamma$.

The syntax and typing rules related to locality are in
Fig.\ref{fig:typing-locality}
\begin{figure}
\begin{align*}
  \mathrm{types}, \tau ::=\;& \ldots \mid \glob \tau \mid \ldots \\
  \mathrm{contexts}, \Gamma ::=\;& \ldots \mid \gbind{\Gamma}{x}{\tau} \\
  \mathrm{values}, v :=\;& \ldots \mid \gbox{v} \mid \gunbox{x}{v}{v} \mid
                           \casebox{v}{x}{v}{x}{v} \mid \grun{c} \mid \ldots \\
  \mathrm{modalities}, m ::=\;& \text{\textvisiblespace} \mid \glob
\end{align*}
\begin{mathpar}
\inferrule{\\}
{\gbind{\Gamma}{x}{\tau} \turnv x \types \tau}
\and
\inferrule{\cdiv{\Gamma} \turnv v \types \tau}
{\Gamma \turnv \gbox{v} \types \glob \tau}
\and
\inferrule{\Gamma \turnv v_1 \types \glob \tau_1 \\
           \gbind{\Gamma}{x}{\tau_1} \turnv v_2 \types \tau_2}
{\Gamma \turnv \gunbox{x}{v_1}{v_2} \types \tau_2}
\and
\inferrule{\cdiv{\Gamma} \turnv v_1 \types \tau_1 + \tau_2 \\
           \gbind{\Gamma}{x_1}{\tau_1} \turnv v_2 \types \tau_3 \\
           \gbind{\Gamma}{x_2}{\tau_2} \turnv v_3 \types \tau_3}
{\Gamma \turnv \casebox{v_1}{x_1}{v_2}{x_2}{v_3} \types \tau_3}
\and
\inferrule{\cdiv{\Gamma} \turnc c \types \tau}
{\Gamma \turnv \grun{c} \types \tau}
\end{mathpar}
\caption{Locality syntax and typing rules}
\label{fig:typing-locality}
\end{figure}

\subsection{Signatures and inductive types}

Effect reflection requires, for any signature $\Sigma$ that is being
reflected, an inductive type $\ind{\Sigma}$ to represent the free
algebras of $\Sigma$. $\ind{\Sigma}$ is sometimes called the \emph{freer
  monad} of $\Sigma$~\cite{kiselyov2015freer}.

As is standard for algebraic effects systems, we only support handlers
for algebraic theories without any equations, even though our semantics
is defined in terms of arbitrary theories. We define algebraic
signatures $\Sigma$ as finite sets of operations:
\begin{equation*}
\{ op_1 \types \tau_{p_1} \rightarrowtail \tau_{a_1}; \ldots; op_n
\types \tau_{p_n} \rightarrowtail \tau_{a_n} \}
\end{equation*}
An operation type $\tau_p \rightarrowtail \tau_a$ indicates an operation
parameterized by $\tau_p$ and with arity $\tau_a$.

\begin{example}
  The signature for boolean state, which we'll call $\Sigma_{bs}$
  is:
  \begin{equation*}
    \{ \mathrm{get} \types 1 \rightarrowtail (1 + 1);
       \mathrm{set} \types (1 + 1) \rightarrowtail 1 \}
  \end{equation*}
\end{example}

We also allow the sum of two signatures $\Sigma_1 + \Sigma_2$ to be used
as a signature. It has operations:
\begin{align*}
\{ \; &\mathrm{left}(op_{1,1}) \types \tau_{p_{1,1}} \rightarrowtail \tau_{a_{1,1}}
        \seq \ldots \seq
        \mathrm{left}(op_{1, n}) \types \tau_{p_{1, n}} \rightarrowtail \tau_{a_{1, n}}
        \seq \\
      &\mathrm{right}(op_{2, 1}) \types \tau_{p_{2, 1}} \rightarrowtail \tau_{a_{2,1}}
        \seq \ldots \seq
        \mathrm{right}(op_{2, m}) \types \tau_{p_{2, m}} \rightarrowtail \tau_{a_{2, m}}
        \; \}
\end{align*}
where $op_{1,1} \seq \ldots \seq op_{1,n}$ are the operations of
$\Sigma_1$ and $op_{2,1} \seq \ldots \seq op_{2,m}$ are the operations
of $\Sigma_2$.

For each operation $op \types \tau_p \rightarrowtail \tau_a$,
$\ind{\Sigma}(\tau)$ has a constructor $\indintro{\Sigma}{op}{v_p}{v_k}$
where $v_p \types \glob \tau_p$ and
$v_k \types \glob \tau_a \rightarrow \ind{\Sigma}(\tau)$. $\ind{\Sigma}(\tau)$
also has a constructor $\ret{\Sigma}{v}$ where $v \types \glob \tau$.

The eliminator for $\ind{\Sigma}$ is written
\begin{align*}
\indelim{\Sigma}{v_s}
  {&\indretcase{x}{v_r} \seq \\
   &\indcase{op_1}{x_{p_1}}{x_{k_1}}{v_1} \seq \\
   &\ldots \seq \\
   &\indcase{op_n}{x_{p_n}}{x_{k_n}}{v_n}}
\end{align*}
The syntax and typing rules for inductive types are shown in
Fig.\ref{fig:typing-inductive}.

As with $\casename$, $\indelimname$ is defined as a value and we can
define a computation version in terms of it.

The global comonad distributes over inductive types, which we realize
via $\indelimboxname$, a global form of the $\indelimname$ construct,
which allows you to match on a global inductive type and get out global
components.

For convenience, we also define the following abbreviation:
\begin{align*}
    \letret{\Sigma}{x}{c_1}{c_2} := \quad &\letv{x_s}{c_1}{\\
        &\indelim{\Sigma}{x_s}{ \\
        &\qquad \indretcase{x}{c_2} \seq \\
        &\qquad \indcase{op_1}{x_{p_1}}{x_{k_1}}{\return{\indintro{\Sigma}{op_1}{x_{p_1}}{x_{k_1}}}} \seq \\
        &\qquad \ldots \seq \\
        &\qquad \indcase{op_n}{x_{p_n}}{x_{k_n}}{\return{\indintro{\Sigma}{op_n}{x_{p_n}}{x_{k_n}}}}}}
\end{align*}

\begin{figure}
\begin{align*}
  \mathrm{types}, \tau ::=\;& \ldots \mid \ind{\Sigma}(\tau) \mid \ldots \\
  \mathrm{signatures}, \Sigma ::=\;& \{ op \types \tau \rightarrowtail \tau \seq \ldots
                                       \seq op \types \tau \rightarrowtail \tau \}
                                     \mid \Sigma + \Sigma \\
  \mathrm{values}, v :=\;& \ldots \mid \indintro{\Sigma}{op}{v}{v}
                           \mid \ret{\Sigma}{v} \mid \\
                         & \indelimm{\Sigma}{v}
                           {\indretcase{x}{v} \seq
                           \indcase{op}{x}{x}{v} \seq \ldots
                           \seq \indcase{op}{x}{x}{v}} \ldots
\end{align*}
\begin{mathpar}
\inferrule{op \types \tau_1 \rightarrowtail \tau_2 \in \Sigma \\
           \cdiv{\Gamma} \turnv v_1 \types \tau_1 \\
           \Gamma \turnv v_2 \types \glob \tau_2 \rightarrow \ind{\Sigma}(\tau)}
{\Gamma \turnv \indintro{\Sigma}{op}{v_1}{v_2} \types \ind{\Sigma}(\tau)}
\and
\inferrule{\cdiv{\Gamma} \turnv v \types \tau}
{\Gamma \turnv \ret{\Sigma}{v} \types \ind{\Sigma}(\tau)}
\and
\inferrule{\cmdiv{\Gamma} \turnv v_s \types \ind{\Sigma}(\tau_1) \\
           \Sigma = \{ op_1 \types \tau_{p_1} \rightarrowtail \tau_{a_1};
             \ldots; op_n\types \tau_{p_n} \rightarrowtail \tau_{a_n} \} \\
           \gbind{\Gamma}{x_r}{\tau_1} \turnv v_r \types \tau_2 \\
           \mbind{\gbind{\Gamma}{x_{p_1}}{\tau_{p_1}}}{x_{k_1}}{\glob \tau_{a_1} \rightarrow \tau_2} \turnv v_1 \types \tau_2 \\
           \ldots \\
           \mbind{\gbind{\Gamma}{x_{p_n}}{\tau_{p_n}}}{x_{k_n}}{\glob \tau_{a_n} \rightarrow \tau_2} \turnv v_n \types \tau_2}
{\Gamma \turnv \indelimm{\Sigma}{v_s}{\indretcase{x_r}{v_r} \seq
                                   \indcase{op_1}{x_{p_1}}{x_{k_1}}{v_1} \seq \ldots \seq
                                   \indcase{op_n}{x_{p_n}}{x_{k_n}}{v_n}} \types \tau_2}
\end{mathpar}
\caption{Inductive type syntax and typing rules}
\label{fig:typing-inductive}
\end{figure}

\begin{example}
  \label{example:negate}
  The following value of type $\ind{\Sigma_{bs}}$ represents a
  reified computation that negates the value of the state:
  \begin{align*}
    &\indintro{\Sigma_{bs}}{get}{()}{\\
      &\quad\abs{x_a}{1 + 1}{\\
        &\qquad \letv{x_n}{\app{\mathit{negate}}{x_a}}{\\
          &\qquad \indintro{\Sigma_{bs}}{set}{x_n}{\abs{x_u}{1}{\ret{\Sigma_{bs}}{x_u}}}}}}
  \end{align*}
  where $\mathit{negate}$ is the function that negates a boolean.
\end{example}

\todo{The above is missing boxing operations}

\subsection{Effect reflection}

The language provides a type $\yoneda{\Sigma}$ for each $\Sigma$ to
represent mappings from the operations of $\Sigma$ into the current
ambient monad. Effect reflection appears in the language as two
constructs: reflection and reification. Reflection $\performraw{v}{op}$
uses a value of type $\yoneda{\Sigma}$ to map the operation $op$ from
$\Sigma$ into the ambient monad.  Reification $\reifyraw{\Sigma}$
extends the ambient monad with the operations from $\Sigma$, providing a
value of type $\yoneda{\Sigma}$ for constructing those operations via
reflection.  These constructs implement the core isomorphism of effect
reflection: reification can convert functions
$\yoneda{\Sigma} \rightarrow \glob \tau$ into terms
$\ind{\Sigma}(\tau)$, while reflection provides the inverse
direction. Their syntax and typing rules are shown in
Fig.\ref{fig:typing-reflection}.

\begin{figure}
\begin{align*}
  \mathrm{types}, \tau ::=\;& \ldots \mid \yoneda{\Sigma} \mid \ldots \\
  \mathrm{values}, v :=\;& \ldots \mid \outl{v} \mid \outr{v} \\
  \mathrm{computations}, c :=\;& \ldots \perform{v}{op}{v}{x}{c} \mid \reify{\Sigma}{x}{c}
\end{align*}
\begin{mathpar}
\inferrule{\Gamma \turnv v \types \yoneda{\Sigma_1 + \Sigma_2}}
{\Gamma \turnv \outl{v} \types \yoneda{\Sigma_1}}
\and
\inferrule{\Gamma \turnv v \types \yoneda{\Sigma_1 + \Sigma_2}}
{\Gamma \turnv \outr{v} \types \yoneda{\Sigma_2}}
\and
\inferrule{\Gamma \turnv v_1 \types \yoneda{\Sigma} \\
           op \types \tau_1 \rightarrowtail \tau_2 \in \Sigma \\
           \cdiv{\Gamma} \turnv v_2 \types \tau_1 \\
           \lbind{\Gamma}{x}{\glob \tau_2} \turnc c \types \tau_3}
{\Gamma \turnc \; \perform{v_1}{op}{v_2}{x}{c} \types \tau_3}
\and
\inferrule{\lbind{\Gamma}{x}{\yoneda{\Sigma}} \turnc c \types \glob \tau}
{\Gamma \turnc \; \reify{\Sigma}{x}{c} \types \ind{\Sigma}(\tau)}
\end{mathpar}
\caption{Effect reflection syntax and typing rules}
\label{fig:typing-reflection}
\end{figure}

Note that we treat reflection of individual operations
$\performraw{v}{op}$ as primitive. We can define reflection of
terms $\reflectraw{\Sigma}$ in terms of $\performraw{v}{op}$:
\begin{align*}
    \reflect{\Sigma}{v}{c} := \quad &\letv{x_w}{c}{\\
        &\indelim{\Sigma}{x_w}{ \\
        &\qquad \indretcase{x_r}{\return{x_r}} \seq \\
        &\qquad \indcase{op_1}{x_{p_1}}{x_{k_1}}
          {\perform{v}{op_1}{x_{p_1}}{x_{a_1}}{(\app{x_{k_1}}{x_{a_1}})}} \seq \\
        &\qquad \ldots \seq \\
        &\qquad \indcase{op_n}{x_{p_n}}{x_{k_n}}
          {\perform{v}{op_n}{x_{p_n}}{x_{a_n}}{(\app{x_{k_n}}{x_{a_n}})}}}}
\end{align*}
which has this admissible typing rule:
\begin{mathpar}
\inferrule{\Gamma \turnv v \types \yoneda{\Sigma} \\
           \Gamma \turnv c \types \ind{\Sigma}(\tau)}
{\Gamma \turnc \; \reflect{\Sigma}{v}{c} \types \glob \tau}
\end{mathpar}

We also provide projections $\outl$ and $\outr$ that decompose a mapping
for $\Sigma_1 + \Sigma_2$ into mappings for $\Sigma_1$ and $\Sigma_2$
respectively.

\begin{example}
  The value from Example~\ref{example:negate} can be constructed via reflection as:
  \begin{align*}
    &\reify{\Sigma_{bs}}{x_h}{\\
      &\qquad \perform{x_h}{get}{()}{x_a}{\\
        &\qquad \qquad \letv{x_n}{\app{\mathit{negate}}{x_a}}{\\
          &\qquad \qquad \perform{x_h}{set}{x_n}{x_u}{\return{x_u}}}}}
  \end{align*}
  where $\mathit{negate}$ is the function that negates a boolean.
\end{example}


\subsection{Operational semantics}
\label{sec:operational}

We define the operational semantics as a pair of mutually defined
reduction relations $\reducestov$ and $\reducestoc$ for values and
computations respectively shown in Fig.\ref{fig:reduction}. The
definitions of normal forms for values and computations are given in
Fig.\ref{fig:normal}.

\begin{figure}
\begin{align*}
\fst{(v_1, v_2)} &\reducestov v_1 \\
\snd{(v_1, v_2)} &\reducestov v_2 \\
\casem{(\inl{v_1})}{x_1}{v_2}{x_2}{v_3} &\reducestov \sbst{v_2}{x_1}{v_1} \\
\casem{(\inr{v_1})}{x_1}{v_2}{x_2}{v_3} &\reducestov \sbst{v_3}{x_2}{v_1} \\
\gunbox{x}{\gbox{v_1}}{v_2} &\reducestov \sbst{v_2}{x}{v_1} \\
\grun{\return{v}} &\reducestov v \\
\grun{\letv{x_1}{c_1}{c_2}} &\reducestov \grun{\sbst{c_2}{x_1}{\grun{c_1}}} \\
\indelimm{\Sigma}{(\ret{\Sigma}{v_s})}{\indretcase{x}{v_r} \seq \ldots} &\reducestov \sbst{v_r}{x}{v_s} \\
\indelimm{\Sigma}{(\indintro{\Sigma}{op}{v_1}{v_2})}{H_1 \seq \indcase{op}{x_1}{x_2}{v_3} \seq H_2} \reducestov \\
  \sbst{\sbst{v_3}{x_1}{v_1}}{x_2}{\abs{x_a}{\tau_a}{&\letv{x_w}{\app{v_2}{x_a}}{\return{\indelimm{\Sigma}{x_w}{H_1 \seq \indcase{op}{x_1}{x_2}{v_3} \seq H_2}}}}} \\
\letv{x}{\return{v}}{c} &\reducestoc \sbst{c}{x}{v} \\
\letv{x_2}{\letv{x_1}{c_1}{c_2}}{c_3} &\reducestoc \letv{x_1}{c_1}{\letv{x_2}{c_2}{c_3}}\\
\letv{x_1}{\perform{v_1}{op}{v_2}{x_2}{c_1}}{c_2} &\reducestoc \perform{v_1}{op}{v_2}{x_2}{\letv{x_1}{c_1}{c_2}} \\
\app{(\abs{x}{\tau}{c})}{v} &\reducestoc \sbst{c}{x}{v} \\
\reify{\Sigma}{x}{\return{v}} &\reducestoc \return{\ret{\Sigma}{v}} \\
\reify{\Sigma}{x_1}{\letv{x_2}{c_1}{c_2}} &\reducestoc \letret{\Sigma}{x_2}{\reify{\Sigma}{x_1}{c_1}}{\reify{\Sigma}{x_1}{c_2}} \\
\reify{\Sigma}{x_1}{\perform{x_1}{op}{v}{x_2}{c}} &\reducestoc \return{\indintro{\Sigma}{op}{v}{\abs{x_2}{\tau}{\reify{\Sigma}{x_1}{c}}}} \\
\reify{\Sigma}{x_1}{\perform{x_2}{op}{v}{x_3}{c}} &\reducestoc \perform{x_2}{op}{v}{x_3}{\reify{\Sigma}{x_1}{c}} \qquad (x_1 \neq x_2) \\
\perform{(\outl{v_1})}{op}{v_2}{x}{c} &\reducestoc \perform{v_1}{\mathrm{left}(op)}{v_2}{x}{c} \\
\perform{(\outr{v_1})}{op}{v_2}{x}{c} &\reducestoc \perform{v_1}{\mathrm{right}(op)}{v_2}{x}{c}
\end{align*}
\caption{Reduction relations}
\label{fig:reduction}
\end{figure}
\begin{figure}
\begin{align*}
  \mathrm{neutral\ values}, \eta :=\;& x \mid \fst \eta \mid \snd \eta \mid \\
                                   &\case{\eta}{x}{\omega}{x}{\omega} \mid \\
                                   &\casebox{\eta}{x}{\omega}{x}{\omega} \mid \\
                                   &\gunbox{x}{\eta}{\omega} \mid \grun{\mu} \mid \\
                                   &\indelim{\Sigma}{\eta}
                                     {\indretcase{x}{\omega} \seq
                                     \indcase{op}{x}{x}{\omega} \seq \ldots \seq
                                     \indcase{op}{x}{x}{\omega}} \\
  \mathrm{neutral\ computations}, \mu :=\;& \app{\eta}{\omega}
                                            \mid \reify{\Sigma}{x}{\mu} \\
  \mathrm{normal\ values}, \omega :=\;& \eta \mid (\omega, \omega)
                           \mid () \mid \inl{\omega} \mid \inr{\omega} \mid \abs{x}{\tau}{\gamma} \mid \\
                           &\indintro{\Sigma}{op}{\omega}{\omega} \mid \ret{\Sigma}{\omega} \mid \\
                           &\gbox{\omega} \mid \outl{\omega} \mid \outr{\omega} \\
  \mathrm{normal\ computations}, \gamma :=\;& \mu \mid \return{\omega}
                                              \mid \letv{x}{\mu}{\gamma}
                                               \mid \perform{\eta}{op}{\omega}{x}{\gamma}
\end{align*}
\caption{Normal forms}
\label{fig:normal}
\end{figure}

We prove subject reduction for this semantics in
Appendix~\ref{apdx:subject-reduction} by straightforward induction on
the reduction relations.
\begin{lemma}
\label{lemma:subject-reduction}
  \begin{equation*}
    \Gamma \turnv v_1 \types \tau
    \wedge v_1 \reducestov v_2 \implies \Gamma \turnv v_2 \types \tau
  \end{equation*}
\end{lemma}

These reduction relations are strongly normalizing. We prove this via
Tait computability\cite{??} in
Appendix~\ref{apdx:strong-normalization}. This is made more involved by
the presence of infinitary inductive types, which requires us to
\todo{something something Knaster-Tarski}.
\begin{lemma}
\label{lemma:strong-normalization}
\todo{Find simplest formal description of strong normalization}
\end{lemma}

\subsection{Embedding the Simply-Typed Lambda Calculus}

Using the global modality and $\grun{c}$ construct we can embed the
Simply Typed Lambda Calculus (STLC) into this language as values. This
demonstrates that the language is a proper extension of STLC. We define
an embedding $\embed{\_}$ on types, contexts and terms of STLC in
Fig.\ref{fig:stlc}. Note that $\reducestov$ matches the behaviour of
$\beta$ reduction of STLC too, with each STLC reduction step
corresponding to up to 3 steps of $\reducestov$.
\begin{figure}
\begin{equation*}
\begin{aligned}[c]
  &\embed{1} = 1 \\
  &\embed{A \times B} = \embed{A} \times \embed{B} \\
  &\embed{A \rightarrow B} = (\glob \embed{A}) \rightarrow \embed{B} \\ \\
  &\embed{\cempty} = \cempty \\
  &\embed{\lbind{\Gamma}{x}{A}} = \gbind{\embed{\Gamma}}{x}{\embed{A}}
\end{aligned}
\qquad
\begin{aligned}[c]
  &\embed{x} = x \\
  &\embed{(e, f)} = (\embed{e}, \embed{f}) \\
  &\embed{\fst{e}} = \fst{\embed{e}} \\
  &\embed{\snd{e}} = \snd{\embed{e}} \\
  &\embed{\abs{x}{A}{e}} =
    \abs{x^{\prime}}{\glob \embed{A}}{\return{(\gunbox{x}{x^{\prime}}{\embed{e}})}} \\
  &\embed{\app{f}{e}} = \grun{\app{\embed{f}}{(\gbox{\embed{e}})}}
\end{aligned}
\end{equation*}
\caption{Embedding of Simply-Typed Lambda Calculus into values}
\label{fig:stlc}
\end{figure}

\todo{Prove that this embedding respects reduction of STLC}

\section{The ambient monad model}
\label{sec:semantics}

The design of effect reflection falls out naturally from a novel
semantic model built on presheaves. This semantic foundation not only
validates our approach but also makes the connection between locality
and effects precise. The key idea is to index the meaning of types by an
ambient algebraic monad of effects: rather than have the semantics of
each type be a set of elements, the semantics of each type is a mapping
from the ambient monad to a set of elements. We give a denotational
semantics to the language from Section~\ref{sec:language} using this
model.

\subsection{Algebraic monads}

In order to index the meaning of our types by the ambient monad we need
some way of representing that ambient monad. As with all approaches to
algebraic effects, we must restrict ourselves to monads that have some
nice properties, in particular we need the sum of two of these monads to
always exists.

To this end, we will restrict the ambient monad to be an \emph{algebraic
  monad}: one that can be expressed as the free algebras of an algebraic
theory. Note that this definition of algebraic monad is not precise:
different choices for the definition of ``algebraic theory'' give you
different meanings for ``algebraic monad''. We'll make our particular
choice over the course of this section.

We recall the definitions of algebraic signature, terms of a signature,
algebraic theory and models of a theory.
\begin{definition}[Algebraic signature]
  An \emph{algebraic signature} is a set of operations with associated
  arities.
\end{definition}

\begin{example}
  The algebraic signature for boolean state $\Sigma_{bs}$ is:
  \begin{equation*}
    \{ (\mathrm{get}, 2); (\mathrm{set\_true}, 1); (\mathrm{set\_false}, 1) \}
  \end{equation*}
\end{example}

\begin{definition}[Term]
  A \emph{term} $t$ of some algebraic signature $\Sigma$ is either a
  free variable $x$ or $op(t_1, \ldots, t_k)$ where $op$ is an operation
  of $\Sigma$ with arity $k$ and each $t_i$ is itself a term.
\end{definition}

\begin{definition}[Algebraic theory]
  An \emph{algebraic theory} consists of an algebraic signature $\Sigma$ and a set of
  equations on terms of $\Sigma$.
\end{definition}

\begin{example}
  The algebraic theory for boolean state $L_{bs}$ adds the following
  equations to the signature of boolean state $\Sigma_{bs}$:
  \begin{align*}
    &\mathrm{set\_true}(\mathrm{get}(x, y)) = \mathrm{set\_true}(x)
    &\mathrm{set\_false}(\mathrm{get}(x, y)) = \mathrm{set\_false}(y) \\
    &\mathrm{set\_true}(\mathrm{set\_true}(x)) = \mathrm{set\_true}(x)
    &\mathrm{set\_true}(\mathrm{set\_false}(x)) = \mathrm{set\_false}(x) \\
    &\mathrm{set\_false}(\mathrm{set\_true}(x)) = \mathrm{set\_true}(x)
    &\mathrm{set\_false}(\mathrm{set\_false}(x)) = \mathrm{set\_false}(x) \\
    &\mathrm{get}(\mathrm{set\_true}(x), \mathrm{set\_false}(x))) = x
  \end{align*}
\end{example}

\begin{definition}[Model]
  A \emph{model} $M$ of some algebraic theory $L$ consists of a carrier
  set $S$ and for each operation $op$ in the signature of $L$ a function
  $op_M : (\Pi_k S) \rightarrow S$ where $k$ is the arity of $op$, such
  that the equations of $L$ are respected when interpreting the terms
  using these functions for the operations. Models of $L$ are also
  called algebras of $L$.
\end{definition}

\begin{example}
  We can model the theory of boolean state $L_{bs}$ using the carrier
  set $2 \rightarrow 2$ and interpreting the operations with:
  \begin{align*}
    &\mathrm{get}(x, y) = \lambda s.\, \mif s \mthen x(s) \melse y(s) \\
    &\mathrm{set\_true}(x) = \lambda s.\, x(\mathrm{true}) \\
    &\mathrm{set\_false}(x) = \lambda s.\, x(\mathrm{false})
  \end{align*}
\end{example}

Arities in algebraic signatures are often considered as natural numbers,
but they can equivalently be just sets, with families of terms indexed
by that set used as the arguments of that operator in a term. It is also
convenient to allow families of operations parameterized by some set. As
such, we can present a signature in the form:
\begin{equation*}
\{ op_1 \types P_1 \rightarrowtail A_1; \ldots; op_n
\types P_n \rightarrowtail A_n \}
\end{equation*}
where $op \types P \rightarrowtail A$ indicates an operation $op$
parameterized by $P$ and with arity $A$.

\begin{example}
  The algebraic signature for boolean state $\Sigma_{bs}$ can be written
  as:
  \begin{equation*}
    \{ \mathrm{get} \types 1 \rightarrowtail 2; \mathrm{set} \types 2 \rightarrowtail 1 \}
  \end{equation*}
\end{example}

Given an algebraic theory $L$ and a set $A$ we can construct
the free model, or \emph{free algebra}, $T_L(A)$. The values $T_L(A)$
are terms built using the elements of $A$ and the operations of $L$
quotiented by the equations in $L$. $T_L$ is a monad and $T$ is one half
of an equivalence between algebraic theories and algebraic monads.

\begin{example}
  The free algebras of the signature of boolean state $T_{\Sigma_{bs}}$
  are equivalent to the type:
  \begin{lstlisting}[style=oxcaml]
  type 'a t =
    | Return of 'a
    | Get of unit * (bool -> 'a t)
    | Set of bool * (unit -> 'a t)
  \end{lstlisting}
  The free algebras of the theory of boolean state $T_{L_{bs}}$ are
  equivalent to the above type quotiented by the equations of $L_{bs}$.
\end{example}

For an algebraic signature $\Sigma$ the free algebra $T_{\Sigma}$ is the
free monad of an endofunctor $F_{\Sigma}$. The values of $F_{\Sigma}(A)$
are of the form $op(a_1, \ldots, a_k)$ where $op$ is an operation of
$\Sigma$ with arity $k$ and each $a_i$ is an element of $A$.
\begin{example}
  $F_{\Sigma_{bs}}$ is equivalent to the type:
  \begin{lstlisting}[style=oxcaml]
  type 'a t =
    | Get of unit * (bool -> 'a)
    | Set of bool * (unit -> 'a)
  \end{lstlisting}
\end{example}

Traditional algebraic signatures are restricted to the case of a finite
set of operations each with a finite arity, but programming languages
require more generality. $\nat$ state needs countable arities, while
$\nat \rightarrow \nat$ state requires uncountable arities.  For these
we must extend algebraic signatures to allow for arbitrary sets of
operations with arbitrary sets as arities. Such algebraic theories are
called \emph{bounded infinitary algebraic theories}. They are
``bounded'' because for each such theory there is some regular cardinal
$\kappa$ that is a bound on the arities of the theory. An algebraic
theory with some bound $\kappa$ corresponds to a monad with rank
$\kappa$. Thus we take monads with a rank as our precise definition of
algebraic monad.

Most monads used in practice for programming are algebraic by this
definition, with the notable exception of the continuation monad. The
issue with trying to represent non-algebraic monads algebraically is
essentially one of size: if you try to write down the collection of
algebraic operations for the continuation monad you get something that
is too large to be a set. This is closely related to the strict
positivity restriction on inductive type definitions.

\subsection{(Bounded) Lawvere theories}

We use \emph{Lawvere theories} as our concrete representation of the
ambient algebraic monad. Lawvere theories are a categorical
representation of algebraic theories that doesn't depend on the
particular choice of operations and equations.

\begin{definition}
  A \emph{Lawvere theory} is a category $L$ with finite products in
  which every object is isomorphic to some finite cartesian product
  $X^n = X \times \ldots \times X$ of a distinguished object $X$.
\end{definition}
The objects of a Lawvere theory correspond to the different possible
arities and the morphisms $X^n \rightarrow X$ correspond to terms
of $L$ with $n$ free variables quotiented by the equations in $L$. A
model of a Lawvere theory $L$ is a product-preserving functor
$L \rightarrow \setc$.

Lawvere theories correspond to the traditional form of algebraic
theories: those with a finite set of operations with finite arities, but
we can extend the definition to get something that corresponds to
\emph{bounded infinitary algebraic theories}.
\begin{definition}
  A \emph{Bounded Lawvere theory} is a small category $L$ with small
  products in which every object is isomorphic to some small cartesian
  product $\Pi_S X$ of a distinguished object $X$.
\end{definition}
Note that the ``bounded'' aspect of the definition comes from the
restriction that the category be small.

We will mostly describe Lawvere theories and constructions on them in
terms of their presentations as algebraic theories, so an understanding
the details of Lawvere theories is not required for understanding the
rest of this paper.

Bounded Lawvere theories form a category $\lawc$ whose morphisms are
equivalent to maps from the operations of one theory to the operations
of another that preserve the equations of the first theory according to
the equations of the second.

$\lawc$ has an initial object $\initial$, which is the algebraic theory
with no operations. It also has coproducts $L + L^{\prime}$ which is the
theory made by unioning the operations and equations of $L$ and
$L^{\prime}$.

\subsection{Presheaves}

For a category $\cat$, $\psh = \setc^{\catop}$ is the category of
presheaves over $\cat$. Its objects are contravariant functors from
$\cat$ to $\setc$ and it's morphisms are natural transformations between
such functors.

A common use of presheaves is where $\cat$ has finite products and is
thought of as some form of context over which everything is
parameterized. We use presheaves over $\lawc$ because types should be
parameterized by the ambient algebraic theory--but contravariantly,
since we want to be parameterized by theories that can be handled by the
ambient monad.

As such, we use
\begin{equation*}
  \pshlawcop = \setc^{\lawc}
\end{equation*}
as the basis of the ambient monad model. The $\op$ in the definition of
presheaves and the $\op$ due to our dependence being contravariant
cancel out, but it is still best to think in terms of presheaves as that
is a more precise description of what we are doing.

The ambient monad model uses objects from $\pshlawcop$ to represent
types and contexts, and morphisms in $\pshlawcop$ to represent
values. This allows their meanings to be parameterized by the ambient
monad. By using presheaves rather than ordinary functions we ensure
terms and types at a particular ambient monad can always be mapped
naturally to a larger ambient monad.

\begin{equation*}
\sem{\tau} \mathrel{:} \pshlawcop \qquad
\sem{\Gamma} \mathrel{:} \pshlawcop \qquad
\sem{\Gamma \turnv v \types \tau} \mathrel{:} \homset{\pshlawcop}{\sem{\Gamma}}{\sem{\tau}}
\end{equation*}

Categories of presheaves have products and coproducts, which are defined
pointwise. We will use these as the semantics of product types and sum
types.
\begin{equation*}
\sem{1} = 1 \qquad
\sem{\tau_1 \times \tau_2} = \sem{\tau_1} \times \sem{\tau_2} \qquad
\sem{\tau_1 + \tau_2} = \sem{\tau_1} + \sem{\tau_2} \qquad
\end{equation*}
The semantics of the corresponding introduction and elimination forms
follows the usual categorical semantics of such types.

We also use products for the semantics of contexts:
\begin{equation*}
\sem{\cempty} = 1 \qquad
\sem{\lbind{\Gamma}{x}{\tau}} = \sem{\Gamma} \times \sem{\tau}
\end{equation*}

\subsection{Representing computations: The free algebras monad}

Our aim is to have a semantics where the meaning of types is indexed by
the ambient monad -- or more precisely by the algebraic theory whose
free algebras are the ambient monad. In particular, we would like the
interpretation of computation types to be applications of the ambient
monad.

Given a Lawvere theory $L$, the underlying sets of its free algebras
form a monad $T_L$ on $\setc$. In addition to the unit of the monad, we
can construct elements of $T_L$ using the operations of $L$. For an
operation $op \types P \rightarrowtail A$ of a Lawvere theory $L$ and
some set $S$, there is a function
$op_{T_L} \types (P \times (A \rightarrow T_L(S))) \rightarrow T_L(S)$
that constructs terms in the free algebra using $op$.

$T_{\_}$ is functorial and we can use it to construct a monad $\mon$ on
$\pshlawcop$ such that:
\begin{equation*}
\mon(P)(L) = T_L(P(L))
\end{equation*}
We call $\mon$ the \emph{free algebras monad}, and it is the
representation of computations in the ambient monad model.
\begin{align*}
  &\sem{\Gamma \turnc v \types \tau} \mathrel{:}
    \homset{\pshlawcop}{\sem{\Gamma}}{\mon(\sem{\tau})} \\
  &\sem{\Gamma \turnc \return{v} \types \tau} =
    \eta_{\sem{\tau}} \circ \sem{\Gamma \turnv v \types \tau} \\
  &\sem{\Gamma \turnc \letv{x}{c_1}{c_2} \types \tau_2} =
    \mu_{\sem{\tau_2}}
    \circ \mon(\sem{\lbind{\Gamma}{x}{\tau_1} \turnc c_2 \types \tau_2})
    \circ t_{\sem{\Gamma}, \sem{\tau_1}}
    \circ \langle id_{\sem{\Gamma}}, \sem{\Gamma \turnc c_1 \types \tau_1} \rangle
\end{align*}
where $\eta$, $\mu$ and $t$ are the unit, multiplication and strength
respectively of $\mon$.

Categories of presheaves also have exponentials, which combine with the
free algebras monad to give us our semantics for function types.
\begin{equation*}
  \sem{\tau_1 \rightarrow \tau_2} = \arrow{\sem{\tau_1}}{\mon(\sem{\tau_2})}
\end{equation*}

\subsection{The global modality}

For any category $\cat$, if $\cat$ has a terminal object $\terminal$, we
can define the global modality $\glob \types [\psh, \psh]$ such that:
$\glob(P)(L) = P(\terminal)$. In the case of $\pshlawcop$ this becomes:
\begin{equation*}
\glob(P)(L) = P(\initial)
\end{equation*}
$\glob$ forms a comonad on $\pshlawcop$. $\glob$ also distributes over
products: $\glob (P \times Q) = (\glob P) \times (\glob Q)$

Within the abient monad model, this amounts to restricting a type to
only the elements which do not depend on the ambient monad. This is very
similar to the purity comonad of Choudhury and
Krishnaswami~\cite{choudhury2020recovering}. In particular,
\begin{equation*}
  \glob \mon(P) \quad = \quad T_{\initial} \circ \glob P
  \quad \cong \quad \glob P
\end{equation*}
as elements of the free algebras of the initial algebraic theory are
just elements of their carrier sets.

We use the $\glob$ comonad as our semantics for $\glob$ types and
$\glob$ bindings.
\begin{align*}
&\sem{\glob \tau} = \glob \sem{\tau} \\
&\sem{\gbind{\Gamma}{x}{\tau}} = \sem{\Gamma} \times \glob \sem{\tau} \\
&\sem{\gbind{\Gamma}{x}{\tau} \turnv x \types \tau} = \epsilon \circ \snd \\
&\sem{\Gamma \turnv \gbox{v} \types \glob \tau} =
  \glob \sem{\cdiv{\Gamma} \turnv v \types \tau}
  \circ \eta \circ \bdiv{\Gamma} \\
&\sem{\Gamma \turnv \gunbox{x}{v_1}{v_2} \types \tau_2} =
  \sem{\gbind{\Gamma}{x}{\tau_1} \turnv v_2 \types \tau_2}
  \circ \langle id_{\sem{\Gamma}},
                \sem{\Gamma \turnv v_1 \types \glob \tau_1} \rangle \\
&\sem{\Gamma \turnv \grun{c} \types \glob \tau} =
  \rho_{\sem{\tau}}
  \circ \glob \sem{\cdiv{\Gamma} \turnc c \types \tau}
  \circ \eta \circ \bdiv{\Gamma}\\
\end{align*}
where $\epsilon$ and $\eta$ are the counit and comultiplication of
$\glob$, $\bdiv{\Gamma} \types \Gamma \rightarrow \cdiv{\Gamma}$ is the
morphism that projects the global bindings from $\Gamma$, and $\rho_P$
is the isomorphism from $\glob \mon(P)$ to $\glob P$.

\subsection{Reflecting operations: The Yoneda embedding}

We want to be able to reflect operations into the ambient monad. We can
use the $op_{T_L}$ functions to build morphisms into $\mon$, but we
require some way to represent operations of the ambient monad. We can do
that by using the \emph{Yoneda embedding}. The Yoneda embedding
$\yoneda{\_}$ is a full and faithful embedding from a category $\cat$
into its category of presheaves $\psh$. When treating $\cat$ as a form
of context, the elements of $y(\catobj)$ can be used to represent
variables of type $\catobj$.

$\lawcop$ embeds into $\pshlawcop$ via the Yoneda embedding: for each
Lawvere theory $L$ there is a presheaf $\yoneda{L}$ in $\pshlawcop$ such
that:
\begin{align*}
&\yoneda{L}(L^{\prime}) = \homset{\lawc}{L}{L^{\prime}} \\
&\yoneda{L}(l^{\prime}) = \lambda f.\; l^{\prime} \circ f
\end{align*}

For an operation $op \types P \rightarrowtail A$ of a Lawvere theory $L$
and some presheaf $P$, we can build a morphism:
\begin{align*}
&op_{\mon{P}} \types
  \homset{\pshlawcop}
         {\yoneda{L} \times \glob P \times \arrow{\glob A}{(\mon{P})}}
         {\mon{P}} \\
&{(op_{\mon{P}})}_{L^\prime}
  = \lambda(y, p, k). (y(op))_{T_{L^\prime}}(p, \lambda a. k_{L^\prime}(id_{L^\prime}, a))
\end{align*}
which uses an element of $\yoneda{L}$ to map $op$ into the ambient monad
and then uses that to construct a term in the free algebras monad.

We use $\yoneda{L}$ as the semantics for our handler types, and
$op_{\mon{P}}$ as the semantics for reflection.
\begin{align*}
&\sem{\yoneda{\Sigma}} = \yoneda{\sem{\Sigma}} \\
&\sem{\Gamma \turnc \perform{v_1}{op}{v_2}{x}{c} \types \tau} = \\
&\quad op_{\mon{\sem{\tau}}}
       \circ \langle \sem{\Gamma \turnv v_1 \types \yoneda{\Sigma}},
                      \sem{\Gamma \turnv v_2 \types \tau_p},
                      \currymap(\sem{\lbind{\Gamma}{x}{\tau_a} \turnc c \types \tau})
             \rangle
\end{align*}
where $\sem{\Sigma}$ is the Lawvere theory corresponding to the
signature $\Sigma$. If $\Sigma$ is:
\begin{equation*}
  \{ \, op_1 \types \tau_{p_1} \rightarrowtail \tau_{a_1} \seq
  \ldots \seq
  op_n \types \tau_{p_n} \rightarrowtail \tau_{a_n} \, \}
\end{equation*}
then $\sem{\Sigma}$ is the Lawvere theory for:
\begin{equation*}
  \{ \, op_1 \types \sem{\tau_{p_1}}(\initial)
                    \rightarrowtail \sem{\tau_{a_1}}(\initial) \seq
  \ldots \seq
  op_n \types \sem{\tau_{p_n}}(\initial)
              \rightarrowtail \sem{\tau_{a_n}}(\initial) \, \}
\end{equation*}
Note that by applying the types to the initial theory $\initial$ we
restrict them to their global elements: those that do not depend on the
current ambient monad.

The Yoneda embedding preserves finite products, which for our case
means:
\begin{equation*}
\yoneda{L + L^{\prime}} \cong \yoneda{L} \times \yoneda{L^{\prime}}
\end{equation*}
which we use for the semantics of $\outlname$ and $\outrname$.

\subsection{Representing effectful computations: The Yoneda lemma}

We can represent computations in a specific algebraic monad using the
Yoneda lemma. The Yoneda lemma says that, for any $P \types \psh$ and
$\catobj \types \cat$, there is an isomorphism:
\begin{equation*}
  \homset{\psh}{\yoneda{\catobj}}{P} \cong P(\catobj)
\end{equation*}

Applying that to the composition of the free algebras monad and the
global modality we get:
\begin{equation*}
  \homset{\pshlawcop}{\yoneda{L}}{\mon{\glob \tau}} \cong \mon{\glob \tau}(L) = T_L(\tau(\initial))
\end{equation*}

In terms of our semantics, this means that computations of type
$\glob \tau$ with a single free variable of type $\yoneda{\Sigma}$ are
isomorphic to values of the free algebra of $\sem{\Sigma}$ at
$\sem{\tau}(\initial)$.

\subsection{Effect reification and inductive types}

The essence of algebraic effect handlers is taking a computation in
$T_{L + \Sigma}(S)$ the free algebras of the sum of an algebraic theory
$L$ and an algebraic signature $\Sigma$, splitting out and handling
$\Sigma$, leaving a computation in only the algebraic theory
$T_{L}(S^\prime)$.

The key to this process is the following
lemma~\cite{hyland2006combining}.
\begin{lemma}
\label{lemma:sums}
  For any Lawvere theory $L$ and algebraic signature $\Sigma$
  \begin{equation*}
  T_{L + \Sigma}(S) \cong \mu X.T_L(S + F_\Sigma(X))
  \end{equation*}
\end{lemma}
where $\mu X.G(X)$ is the initial algebra of some polynomial endofunctor
$G$. This lemma is crucial because it shows that computations using both
ambient effects $L$ and the signature $\Sigma$ can be reorganized as a
recursive structure that separates the two effect sources -- exactly
what effect handlers need.

Effect reification works by exposing $\mu X.T_L(S + F_\Sigma(X))$ to the
user via an inductive type. Categories of presheaves have initial
algebras of polynomial endofunctors, i.e. W-types, so we can construct
the required initial algebra as a presheaf. Given an algebraic
signature $\Sigma$ and a presheaf $P$, we define the following family
of initial algebras:
\begin{align*}
&\ind{\Sigma} \types [\pshlawcop, \pshlawcop] \\
&\ind{\Sigma}(P) = \mu X. ((\glob P) + F_\Sigma \circ \mon{X})
\end{align*}
and observe the following variation on Lemma \ref{lemma:sums}.
\begin{lemma}
\label{lemma:sums2}
  For any Lawvere theory $L$ and algebraic signature $\Sigma$
  \begin{equation*}
  T_{L + \Sigma}(P(\initial)) \cong \mon{(\ind{\Sigma}(P))}(L)
  \end{equation*}
\end{lemma}

We use these initial algebras as the semantics of $\ind{\Sigma}$:
\begin{mathpar}
\sem{\ind{\Sigma}(\tau)} = \ind{\sem{\Sigma}}(\sem{\tau})
\end{mathpar}

Exponentials in categories of presheaves are defined such that:
\begin{equation*}
\arrow{P}{Q}(\catobj) \cong \homset{\psh}{\yoneda{\catobj} \times P}{Q}
\end{equation*}
Applying this to $\arrow{\yoneda{L}}{\mon{(\glob P)}}$ and then applying
the Yoneda Lemma we get:
\begin{align*}
\arrow{\yoneda{L}}{\mon{(\glob P)}}(L^{\prime})
  &\cong \homset{\pshlawcop}{\yoneda{L^{\prime}} \times \yoneda{L}}{\mon{(\glob P)}} \\
  &\cong \homset{\pshlawcop}{\yoneda{L^{\prime} + L}}{\mon{(\glob P)}} \\
  &\cong \mon{(\glob P)}(L^{\prime} + L) \\
  &\cong T_{(L^{\prime} + L)}(P(\initial))
\end{align*}

In the case where $L$ is a signature $\Sigma$, we can further apply
Lemma \ref{lemma:sums2} and, observing that all the steps in this proof
were natural in $L^{\prime}$, produce this isomorphism:
\begin{equation*}
  \arrow{\yoneda{\Sigma}}{\mon{(\glob P)}} \cong \mon{(\ind{\Sigma}(P))}
\end{equation*}
which we call $\reifyc{\Sigma}{}$.

$\reifyc{\Sigma}{}$ gives us our semantics for reification.
\begin{align*}
&\sem{\Gamma \turnc \reify{\Sigma}{x}{c} \types \ind{\Sigma}(\glob \tau)} =
  \reifyc{\Sigma}{\tau} \circ \currymap(\sem{\lbind{\Gamma}{x}{\yoneda{\Sigma}} \turnc c \types \glob \tau}) \\
\end{align*}

\subsection{Properties of the denotational semantics}

The denotational semantics is sound:
\begin{lemma}
\label{lemma:soundness}
  \begin{equation*}
    \Gamma \turnv v_1 \types \tau
    \wedge v_1 \reducestov v_2
    \implies \sem{\Gamma \turnv v_1 \types \tau}
           = \sem{\Gamma \turnv v_2 \types \tau}
  \end{equation*}
\end{lemma}
and adequate for contextual equality $\ctxeq$:
\begin{lemma}
\label{lemma:adequacy}
  \begin{equation*}
    \sem{\turnv v_1 \types \tau} = \sem{\turnv v_2 \types \tau}
    \implies v_1 \ctxeq v_2
  \end{equation*}
\end{lemma}

We present the full semantics, precisely define contextual equality, and
prove these properties in Appendix~\ref{apdx:denotational}.

\section{Implementation}
\label{sec:implementation}

\subsection{Implementation with untracked effect handlers}

We can implement the interface from Section \ref{sec:interface} directly
in terms of OCaml's untracked effect
handlers~\cite{Sivaramakrishnan2021retrofitting}\footnote{For
  convenience, we use the new handler syntax from OCaml 5.3. However,
  the most recently released version of OxCaml is based on OCaml 5.2 so
  the actual implementation uses
  \lstinline[style=oxcaml]{Effect.Deep.match_with} instead}. The trick
is to generate a fresh effect constructor for each reification, pass
that constructor around as part of the
\lstinline[style=oxcaml]{handler}, and then use it to perform operations
during reflection. The full implementation is given in
Fig.\ref{fig:implementation}.

\begin{figure}
\begin{lstlisting}[style=oxcaml]
module Handler (O : Op) = struct

  type t = { perform : 'r. 'r O.t -> 'r }

end

module Reflection (O : Op) = struct
  open Term(O)
  open Handler(O)

  let reify f =
    let module Eff =
      struct type 'a Effect.t += C : 'a O.t -> 'a Effect.t end
    in
    let handler =
      { perform = fun o -> Effect.perform (Eff.C o) }
    in
    match f handler with
    | v -> Return v
    | effect Eff.C o, k -> Op(o, fun x -> Effect.continue k x)

  let reify_local f = exclave
    let module Eff =
      struct type 'a Effect.t += C : 'a O.t -> 'a Effect.t end
    in
    let handler = { perform = fun o -> Effect.perform (Eff.C o) } in
    match f handler with
    | v -> Return v
    | effect Eff.C o, k -> Op(o, fun x -> Effect.continue k x)

  let perform t =
   fun h -> h.perform t

end

module Project (L : Op) (R : Op) = struct
  open Sum(L)(R)

  let outl ({perform} : Handler(Sum(L)(R)).t) : Handler(L).t =
    exclave {perform = fun op -> perform (Left op)}

  let outr ({perform} : Handler(Sum(L)(R)).t) : Handler(R).t =
    exclave {perform = fun op -> perform (Right op)}

end
\end{lstlisting}
\caption{Implementation}
\label{fig:implementation}
\end{figure}

\subsection{More efficient implementation in terms of fibers}

In the implementation in Fig.\ref{fig:implementation}, whenever an
operation is reflected we perform a linear search up the stack of
handlers until we find the corresponding one. This search is not
actually necessary: there is a one-to-one relationship between the
handlers and the handler values used to reflect operations. The linear
search could be eliminated by extending the OxCaml runtime to support
direct references to handlers. By allowing local values to point
directly to the fiber structures that implement effect handlers,
operations can jump immediately to the correct handler without
traversing the stack. This optimization maintains the same interface
while providing constant-time operation dispatch. It is roughly the
implementation technique described by Ma et al.~\cite{ma2024lexical}.

\section{Related work}
\label{sec:related-work}

\subsection{Lexical and named effect handlers}

Effect reflection is closely related to \emph{lexical effect handlers}
in systems such as Effekt~\cite{brachthauser2020effects} or Biernacki et
al.~\cite{biernacki2019binders}. Lexical effect handlers have a value
that represents the effect handler, similar to $\yoneda{\Sigma}$ values,
but these values are second class and require their own special typing
rules. More recent work on Effekt~\cite{brachthauser2022effects}
addresses the second-class nature of these values, but requires further
extending the type system by tracking the set of capabilities used by
each value.

Effect reflection is also closely related to \emph{named effect
  handlers}~\cite{xie2022first}. Named effect handlers use higher-rank
polymorphism to emulate locality tracking in much the same way as the
\lstinline[style=haskell]{St} monad in Haskell. This still requires
using an effect system to track which named effects are used by a
computation, in order to ensure that those effects do not escape the
scope of their handler. Using higher-rank polymorphism also prevents
global type inference, requiring complex inference that extends beyond
classic Hindley-Milner, and demanding a higher annotation burden on the
programmer.

\subsection{Monadic reflection}

Effect reflection is a variation on monadic
reflection~\cite{filinski1999representing}. By restricting ourselves to
algebraic monads with no equations we remove the need to manually define
\emph{glue} functions that describe the interaction between the monad
being reified and the current ambient monad. By using locality and
$\yoneda{\Sigma}$ values we avoid the need to have an effect system.

\subsection{Semantics of algebraic effect handlers}

Hyland et al.~\cite{hyland2006combining} investigate combining algebraic
effects, including the key property of sums of algebraic theories (our
Lemma \ref{lemma:sums}) on which handlers are based.

The original work on algebraic effect
handlers~\cite{plotkin2009handlers,plotkin2013handling} gives a semantics
in terms of free algebras but the semantics work with a fixed algebraic
theory: handlers do not actually change the ambient monad. Our presheaf
semantics naturally accommodates changing ambient monads.

\subsection{Comonadic purity}

Our use of a comonadic global modality to track values which do not
depend on the ambient monad is essentially the same as the purity
comonad described by Choudhury and
Krishnaswami~\cite{choudhury2020recovering}. Their semantic description
of their comonad is very different -- based on a semantics of
capabilities -- but the typing rules, and the practical result, are the
same.

\subsection{Locality and presheaves}

Our presheaf semantics are closely related to presheaf semantics for
higher-order abstract syntax~\cite{hu2022category}. In both cases
presheaves are used to index the semantics of types and terms by some
notion of context, with the Yoneda embedding used to access this context
and the global modality used to control dependence on it.

\bibliography{references}
\bibliographystyle{plain}

\appendix
\section{Operational semantics}
\subsection{Subject reduction}
\label{apdx:subject-reduction}

We prove subject reduction (Lemma~\ref{lemma:subject-reduction}):
\begin{equation*}
  \Gamma \turnv v_1 \types \tau
  \wedge v_1 \reducestov v_2 \implies \Gamma \turnv v_2 \types \tau
\end{equation*}
by mutual induction over the two reduction relations. The reduction
relations are the least reflexive, transitive congruences closed under
the rules in Fig.~\ref{fig:reduction}.

The reflexivity case is immediate and the transitive case follows
directly by induction. As all the typing rules are entirely
compositional, the congruence cases also all follow direectly by
induction. This leaves only the rules from Fig.~\ref{fig:reduction}.

Note that the typing rules are syntax directed with the exception of the
two var rules, which are distinguished by how the variable is bound in
the context. Since none of the left-hand sides of our reduction rules is
a variable, there is always only a single typing rule that we need to
consider.

The cases for the products rules:
\begin{align*}
\fst{(v_1, v_2)} &\reducestov v_1 \\
\snd{(v_1, v_2)} &\reducestov v_2 \\
\end{align*}
follow immediately by inversion on the typing rule.

\begin{equation*}
\gunbox{x}{\gbox{v_1}}{v_2} \reducestov \sbst{v_2}{x}{v_1}
\end{equation*}
\todo{Requires substitution rule of a term under $\cdiv{\Gamma}$ for a
  boxed binding}.

The case for the $\grun$ rule
\begin{equation*}
\grun{\return{v}} \reducestov v
\end{equation*}
\todo{Requires weakening from $\cdiv{\Gamma}$ to $\Gamma$}.

The case for the let-return rule:
\begin{equation*}
\letv{x}{\return{v}}{c} \reducestoc \sbst{c}{x}{v}
\end{equation*}
\todo{Requires ordinary substitution lemma}.

The case for the let-perform rule:
\begin{equation*}
\letv{x_1}{\perform{v_1}{op}{v_2}{x_2}{c_1}}{c_2} \reducestoc \perform{v_1}{op}{v_2}{x_2}{\letv{x_1}{c_1}{c_2}}
\end{equation*}
follows immediately by inversion on the typing rule.

The case for the standard beta rule:
\begin{equation*}
\app{(\abs{x}{\tau}{c})}{v} \reducestoc \sbst{c}{x}{v}
\end{equation*}
\todo{Requires ordinary substitution lemma}.

The cases for the case rules:
\begin{align*}
\case{(\inl{v_1})}{x_1}{v_2}{x_2}{v_3} &\reducestoc \sbst{v_2}{x_1}{v_1}
\case{(\inr{v_1})}{x_1}{v_2}{x_2}{v_3} &\reducestoc \sbst{v_3}{x_2}{v_1}
\end{align*}
\todo{Requires ordinary substitution lemma}.

The case for the $\retname$ rule:
\begin{equation*}
\indelim{\Sigma}{(\ret{\Sigma}{v_1})}{\indretcase{x}{v_2} \seq \ldots} \reducestoc \sbst{v_2}{x}{v_1}
\end{equation*}
\todo{Requires ordinary substitution lemma}.

The case for the $\indintro{\Sigma}{op}{\_}{\_}$ rule:
\begin{align*}
&\indelim{\Sigma}{(\indintro{\Sigma}{op}{v_1}{v_2})}{H_1 \seq \indcase{op}{x_1}{x_2}{v_3} \seq H_2} \\
&\qquad \reducestoc \sbst{\sbst{v_3}{x_1}{v_1}}{x_2}{\abs{x_a}{\tau_a}{\letv{x_w}{\app{v_2}{x_a}}{\indelim{\Sigma}{x_w}{H_1 \seq \indcase{op}{x_1}{x_2}{v_3} \seq H_2}}}}
\end{align*}
\todo{Requires ordinary substitution lemma}.

The case for the return rule:
\begin{equation*}
\reify{\Sigma}{x}{\return{v}} \reducestoc \return{\ret{\Sigma}{v}}
\end{equation*}
\todo{Requires strengthening by local bindings of handlers for global values,
  which doesn't actually hold because you can have global terms that ignore their
  inputs}.

\begin{equation*}
\reify{\Sigma}{x_1}{\perform{x_1}{op}{v}{x_2}{c}} \reducestoc \return{\indintro{\Sigma}{op}{v}{\abs{x_2}{\reify{\Sigma}{x_1}{c}}}}
\end{equation*}

\begin{equation*}
\reify{\Sigma}{x_1}{\perform{x_2}{op}{v}{x_3}{c}} \reducestoc \perform{x_2}{op}{v}{x_3}{\reify{\Sigma}{x_1}{c}} \qquad (x_1 \neq x_2)
\end{equation*}

\begin{equation*}
\perform{(\outl{v_1})}{op}{v_2}{x}{c} \reducestoc \perform{v_1}{\mathrm{left}(op)}{v_2}{x}{c}
\end{equation*}

\begin{equation*}
\perform{(\outr{v_1})}{op}{v_2}{x}{c} \reducestoc \perform{v_1}{\mathrm{right}(op)}{v_2}{x}{c}
\end{equation*}

\subsection{Strong normalization}
\label{apdx:strong-normalization}
\section{Denotational semantics}
\label{apdx:denotational}
\subsection{Soundness}
\subsection{Contextual equivalence}
\subsection{Compositionality}
\subsection{Adequacy}
\end{document}
